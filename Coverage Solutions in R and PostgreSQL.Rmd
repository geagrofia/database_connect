---
title: "Coverage Solutions in PostgreSQL and R"
author: "A Farrow"
date: "08/02/2022 - 08/02/2022"
output:
  html_document:  
    theme: united
    number_sections: yes
    toc: yes
    toc_float: true
    toc_depth: 4
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dpi = 300,
  echo = FALSE,
  results = 'markup' ,
  message = FALSE,
  warning = FALSE
)

```

```{r libraries}
#library(RPostgres) this conflicts with RPostgreSQL so disable
library(RPostgreSQL)
library(DBI)
library(kableExtra)
library(sf)
library(tidyverse)
library(terra)
library(raster)
library(nominatimlite) # used for OSM API and for bounding box
library(rasterVis) # used for plotting rasters
library(osmdata) # used for OSM data
library(osmar) # used for OSM data
library(gdistance) # used for cost distance calculations
library(cowplot) # used for plotting
library(scales) # used for scales in plotting
library(ggtext) # used for superscript in plotting text

sf_use_s2(FALSE)

source("R/R_2_postgres_functions.R")

```

# Objective

In 2010 I published a paper that investigated the locational efficiency of agro-dealers in central Malawi. I analysed the accessibility to existing agro-dealers in a raster environment using the 'costdistance' algorithm in the ESRI Arc/INFO software.

I programmed a 'greedy-add' heuristic in Arc Macro Language (AML), accessing points from shapefiles and raster grids in native ESRI format. This script will investigate how to replicate the heuristic and the accessibility analysis in a PostgreSQL/PostGIS and R environment.

# Introduction

Spatial analysis can help in the expansion of input stockists, especially agro-dealer networks, by assessing the coverage of existing input outlets and deriving optimum locations for these village-level input stockists. 

I address three research questions: 

+ First, what is the locational efficiency of the current village-level stockists of inputs (CNFA-RUMARK trained network of agro-dealers and public sector)? 

+ Secondly, how many village-level stockists of markets are needed to reach 80% of the population in the central region of Malawi within 1 hour? 

+ Finally I address the potential spatial components of the sustainability of input stockists relating to the potential demand from smallholder farmers and the access to bulk supplies. 

The problem of finding the optimum location for village-level stockists of markets is addressed in two stages, using spatial analysis in conjunction with location-allocation models (LAM). 
First, the locational efficiency of the existing network of stockists of inputs (agro dealers) is determined, followed by the establishment of a set of optimal sites for village-level stockists of inputs. A final step explores the viability of stockists and calculates the population surrounding the stockists taking into account competition from other sources of inputs and the accessibility of the selected stockists to potential wholesalers who are bulk distributors of farm inputs.


# AML 'Greedy-Add' heuristic

My previous approach used existing raster accessibility algorithms within a custom made heuristic for determining near optimal locations of stockists. 

The first step was to assess the coverage of set I - the existing CNFA stockists. If more than 20% of the target population is uncovered, then the heuristic selects from set G until at least 80% of the population is serviced within the 1-hour threshold.

The heuristic choose each stockist in set G and records the population within the 1-hour threshold and selects the stockist l with the greatest population coverage. It then recalculates the population coverage and, if the objective is not achieved, the heuristic increases the number of selected stockists from set G. After this first iteration, the search for an optimal solution ought to consider all combinations of stockists from set G. 

The number of combinations is defined by n!/(n-i)!, where n is the total number of stockists and i is the number of stockists in a particular iteration. For large numbers of stockists in set I this is computationally intensive; for instance with 100 stockists in set G finding the greatest population coverage for 3 stockists gives 100 * 99 * 98 = 100!/97! = 970,200 possible combinations.

I use a "greedy add" heuristic instead. Thus in the second iteration the heuristic excludes the population already covered in the first iteration and again searches for the stockist with the greatest population coverage. 
The heuristic proceeds in this fashion until the covered population within 1 hour is 80%, at which point the model stops (Farrow, 2010).


## Spatial Data

Dataset name | Type | Description
-------------|------|-------------
Friction | grid | Values of time in seconds to cross a cell
Boundary | grid |Defining the extent of the analysis with single value of 1
Sumzonegrid | grid | Defining the extent of the population to be analysed with single value of 1
Pop | grid | The uncovered population that are considered at the start of the analysis
Totpop | grid | The total population in the area of analysis
Test_points | shapefile | Locations that can be considered as facilities/outlets


## AML Heuristic Steps

The steps of the heuristic are specific to AML so the order may change depending on the logic of R or PostGIS.
Nevertheless the steps indicate the main processes:

1. DEFINE DIRECTORIES
2. DEFINE POINTS COVERAGE
3. DEFINE GRID COVERAGES
4. GET TOTAL POPSUM IN TEST AREA AND create a variable
5. SHAPEFILE EXTRACTION COMMAND
6. DEFINE OTHER VARIABLES
7. GET USER DEFINED VARIABLE VALUES
8. DEFINE OUTPUT TABLE FOR POPULATION VALUES AND POINT NUMBER
9. START THE ITERATIONS
    + Select point with unique ID and create new layer
    + Convert selected point layer to grid maintaining ID
    + RUN COSTDISTANCE USING FRICTION GRID AND NEW TARGET GRID
    + FIND AREA AND POPULATION WITHIN 1 HOUR
    + COMPARE POPSUM AND RECORD POINT-ID
    + CLEAN UP
    + COMPARE TO TOTAL POP
    + RERUN THE COSTDISTANCE FOR THE OPTIMUM POINT, SAVE AND DISCARD
    + CLEAN UP
  
  
# Conventional raster distance approach

## Connect to PostgreSQL database

The database has the following tables:

```{r db_connect, results='markup'}

con <- dbConnect(
  RPostgres::Postgres(),
  dbname = "R_link",
  host = "localhost",
  port = "5432",
  password = "wagb$^6DF",
  user = "postgres",
  service = NULL
)

# List tables associated with a specific schema
dbGetQuery(con,
           "SELECT table_name FROM information_schema.tables
                   WHERE table_schema='coverage'") %>% kable(caption = "Coverage PostgreSQL Tables") %>% kable_styling("striped", full_width = T)

```

## Get the country boundary

```{r boundary_mwi, , cache=TRUE, fig.height = 7, fig.width = 4, fig.cap = "Malawi Boundary", dev = 'png', results='hide'}

# this gets the Malawi boundary from GADM
boundary_mwi <- getData('GADM', country = ("MWI"), level = 0) %>% st_as_sf() %>% mutate(New_ID = 1)

# this transforms the boundary to the UTM projection for Malawi
boundary_mwi_utm <- st_transform(boundary_mwi, 32736)

# this writes the boundary_mwi to postgres
st_write(obj = boundary_mwi_utm, dsn = con, Id(schema="coverage", table = "boundary_mwi_utm"))

boundary_mwi_plot <- ggplot() +
  geom_sf(data = boundary_mwi_utm)

boundary_mwi_plot

```

## Get the central region boundary

```{r boundary_mcr, , cache=TRUE, fig.height = 7, fig.width = 4, fig.cap = "Malawi Central Region and Districts", dev = 'png', results='hide'}

# this gets the Malawi districts from GADM
boundary_mcr_dist <- getData('GADM', country = ("MWI"), level = 1) %>% st_as_sf() %>% mutate(New_ID = 1) %>%  dplyr::filter(HASC_1 =="MW.DE" | HASC_1 =="MW.KS" | HASC_1 =="MW.NK" | HASC_1 =="MW.DO" | HASC_1 =="MW.MC" | HASC_1 =="MW.LI" | HASC_1 =="MW.SA" | HASC_1 =="MW.NI" | HASC_1 =="MW.NU")

# this transforms the districts to the UTM projection for Malawi
boundary_mcr_dist_utm <- st_transform(boundary_mcr_dist, 32736)

# this writes the districts to postgres
st_write(obj = boundary_mcr_dist_utm, dsn = con, Id(schema="coverage", table = "boundary_mcr_dist_utm"))

# this gets the Central Regiion boundary
boundary_mcr_utm <- st_as_sf(st_union(boundary_mcr_dist_utm))


boundary_mcr_dist_plot <- ggplot() +
  geom_sf(data = boundary_mcr_utm,
          colour = 'grey',
          size = 2) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1
  )

boundary_mcr_dist_plot

```


## Get existing agro-dealer points


This step uses the following SQL scripts:

+ create_table_cnfa_ag_dealers.sql

+ coverage_copy_csv_cnfa_ag_dealers.sql

+ update_geometry_cnfa_ag_dealers.sql



```{r cnfa_ag_dealers, cache=TRUE, fig.height = 7, fig.width = 4, fig.cap = "Existing Agro-Dealers", dev = 'png', results='hide'}

# query to select easting, northing, yield from pg for job
qry <- sprintf(
  "SELECT  Id, ID_ACC, CNFA_Ag_Dealer_Name,  District_Name, X,  Y,  Geom 
                FROM COVERAGE.CNFA_AG_DEALERS"
)

# fetch data from db, 
cnfa_ag_dealers_df <- dbGetQuery(con, qry)


# https://stackoverflow.com/questions/58398074/import-csv-with-postgres-geometry-column-as-sf

#1. convert the geometry strings to sf spatial objects:
newGeom <- st_as_sfc(structure(as.character(cnfa_ag_dealers_df$geom), class = "WKB"),EWKB=TRUE)

#2. create a new spatial data frame with the new spatial objects as geometry
cnfa_ag_dealers_sdf <- st_set_geometry(cnfa_ag_dealers_df, newGeom)

#3. (optional) drop the character format column
cnfa_ag_dealers_sdf$geom=NULL

st_crs(cnfa_ag_dealers_sdf, 32736)

cnfa_ag_dealers_plot <- ggplot() +
  geom_sf(data = boundary_mcr_utm,
          colour = 'grey',
          size = 2) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1
  ) +
  geom_sf(
    data = cnfa_ag_dealers_sdf,
    colour = 'dark green',
    size = 1,
    shape = 3
  )

  
cnfa_ag_dealers_plot

```


## Get potential agro-dealer points

This step uses the following SQL scripts:

+ create_table_pot_ag_dealers.sql

+ create_table_pot_ag_dealers_temp.sql

+ coverage_copy_csv_pot_ag_dealers_temp.sql

+ insert_from_temp.sql

+ update_geometry_pot_ag_dealers.sql



```{r pot_ag_dealers, cache=TRUE, fig.height = 7, fig.width = 4, fig.cap = "Potential Agro-Dealers", dev = 'png', results='hide'}

# query to select easting, northing, yield from pg for job
qry <- sprintf(
  "SELECT  Id, Pot_Ag_Dealer_Name,  District_Name, Facility,  X,  Y,  Geom 
                FROM COVERAGE.POT_AG_DEALERS"
)

# fetch data from db, 
pot_ag_dealers_df <- dbGetQuery(con, qry)


# https://stackoverflow.com/questions/58398074/import-csv-with-postgres-geometry-column-as-sf

#1. convert the geometry strings to sf spatial objects:
newGeom <- st_as_sfc(structure(as.character(pot_ag_dealers_df$geom), class = "WKB"),EWKB=TRUE)

#2. create a new spatial data frame with the new spatial objects as geometry
pot_ag_dealers_sdf <- st_set_geometry(pot_ag_dealers_df, newGeom)

#3. (optional) drop the character format column
pot_ag_dealers_sdf$geom=NULL

st_crs(pot_ag_dealers_sdf, 32736)

pot_ag_dealers_plot <- ggplot() +
  geom_sf(data = boundary_mcr_utm,
          colour = 'grey',
          size = 2) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1
  ) +
  geom_sf(
    data = cnfa_ag_dealers_sdf,
    colour = 'dark green',
    size = 1,
    shape = 3
  ) +
  geom_sf(
    data = pot_ag_dealers_sdf,
    colour = 'blue',
    size = 2,
    shape = 1
  )

pot_ag_dealers_plot

```

## Create the friction surface raster

### Analysis Mask

The analysis mask is an intersection of (i) the bounding box of the central region of Malawi with (ii) the boundary of Malawi.

Movement is permitted across the regional boundary, but the population outside the central region will not be considered.


```{r mask_boundary, cache=TRUE, fig.height = 7, fig.width = 4, fig.cap = "Mask Boundary", dev = 'png', results='hide'}

bbox_central <- bbox_to_poly(st_bbox(boundary_mcr_utm), crs = 32736)

central_mask <- st_intersection(boundary_mwi_utm, bbox_central)

bbox_central_plot <- ggplot() +
  geom_sf(data = bbox_central, colour = 'dark grey', fill = 'light grey') +
  geom_sf(data = boundary_mwi_utm, colour = 'blue', fill = 'light blue') +
  geom_sf(data = central_mask, colour = 'dark green', fill = 'light green')


bbox_central_plot

```

The analysis mask is converted to a raster with resolution of 1km by 1km

```{r mask_raster, cache=TRUE, fig.height = 7, fig.width = 4, fig.cap = "Mask Raster", dev = 'png', results='hide'}

wkt_32736 <- sf::st_crs(32736)[[2]]

e <- extent(central_mask)
blank_raster <- raster(e, resolution = c(1000, 1000))
proj4string(blank_raster) <- sp::CRS(wkt_32736)

mask_raster <- rasterize(central_mask, blank_raster, field=1)
mask_raster

# use gplot from the rastervis package

gplot(mask_raster, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
  #geom_tile() +
  geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  scale_fill_gradient(low = "white",
                      high = 'dark green',
                      na.value = NA) +
  #xlim(-20, 60) +
  #ylim(-40, 40) +
  labs(fill = "-------------\nAnalysis\nMask\n-------------") +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )
  
```

### Slope

The slope is determined by the change in elevation.
I download SRTM data for the central region of Malawi (from the raster package).

```{r srtm_raster, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "SRTM elevation", dev = 'png', results='hide'}

srtm_34_14S <- getData('SRTM', lon=34, lat=-14)
srtm_34_16S <- getData('SRTM', lon=34, lat=-16)
srtm_utm  <- projectRaster(merge(srtm_34_14S, srtm_34_16S), mask_raster)

srtm_c_mwi <- (srtm_utm * mask_raster)

# use gplot from the rastervis package

gplot(srtm_c_mwi, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
  #geom_tile() +
  geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  scale_fill_gradientn(colours = terrain.colors(10),
                       na.value = NA) +
  labs(fill = "-------------\nSRTM\nElevation\n(masl)\n-------------") +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

```

I then convert the elevation into slope (degrees) and then into a metre-by-metre difference.

```{r slope_raster, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "SRTM slope", dev = 'png', results='hide'}


slope_c_mwi <- terrain(srtm_c_mwi, opt="slope", unit="tangent", neighbors = 8)
slope_c_mwi

# use gplot from the rastervis package

gplot(slope_c_mwi, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
  #geom_tile() +
  geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  scale_fill_gradientn(colours = rev(heat.colors(10)),
                       na.value = NA) +
  labs(fill = "-------------\nSRTM\nSlope\nm-in-m\n-------------") +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

```


### Land use

```{r landuse_raster, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Copernicus Land Cover", dev = 'png', results='hide'}


lc_africa <- crop(raster("D:/DatosProyecto/SpatialData/Africa/biofisico/Copernicus/E020N00_PROBAV_LC100_global_v3.0.1_2019-nrt_Discrete-Classification-map_EPSG-4326.tif"), extent(c(30, 36, -20, -10))) 
lc_africa
unique(values(lc_africa))


lc_utm  <- projectRaster(lc_africa, mask_raster, method="ngb")
unique(values(lc_utm))

lc_c_mwi <- (lc_utm * mask_raster)
unique(values(lc_c_mwi))

brks <- c( 0, 35, 45, 55, 85, 95, 150)
nb <- length(brks) - 1
cols <- colorRampPalette(c("yellow", "green", "black", "blue", "light blue", "dark green")) (nb)

# use gplot from the rastervis package

  gplot(lc_c_mwi, maxpixels = 50000) + 
    geom_tile(aes(fill = value), alpha = 1) +
  geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
    scale_fill_gradientn( colours = cols,
                       na.value = NA) +
    labs(fill = "-------------\nCopernicus\nLand Cover\n-------------") +
    theme(
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank()
    )

```


 https://land.copernicus.eu/global/sites/cgls.vito.be/files/products/CGLOPS1_PUM_LC100m-V3_I3.4.pdf page 28


Copernicus land cover classes

Map code | Land Cover Class | Walking speeds km/hr | Reclassification in seconds/km
---------|------------------|----------------------|-----------------------------------
20|Shrubs | 2 | 1800
30|Herbaceous vegetation | 3 | 1200
40|Cultivated and managed vegetation/agriculture (cropland) | 3 | 1200
50|Urban / built up | 5 | 720 
80|Permanent water bodies  | 0.1 | 36000
90|Herbaceous wetland | 1 | 3600
112|Closed forest, evergreen, broad leaf | 1.5 | 2400
114|Closed forest, deciduous broad leaf | 1.5 | 2400
116|Closed forest, unknown  | 1.5 | 2400
124|Open forest, deciduous broad leaf | 1.5 | 2400
126|Open forest, unknown  | 1.5 | 2400


```{r landuse_reclassified, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Copernicus Land Cover", dev = 'png', results='hide'}


### reclassify Land use to give a water raster

lc_c_mwi_rcl_water  <-  reclassify(lc_c_mwi, matrix(c(0, 78, NA, 79,81, 1, 82, 200, NA),
                                                                ncol = 3,
                                                                byrow = TRUE))
lc_c_mwi_rcl_water_df <- gplot_data(lc_c_mwi_rcl_water) # convert to geom_tile type of raster
# multiple geom_tiles can be incorporated in a conventional ggplot


### reclassify Land use

dflc <- data.frame(
  id = c(20,
         30, 40, 50, 80, 90, 112, 114, 116, 124, 126),
  values = c(1800, 1200, 1200, 720, 36000, 3600, 2400, 2400, 2400, 2400, 2400)
)

lc_c_mwi_rcl <- subs(lc_c_mwi, dflc, subsWithNA=TRUE) ## substitute and all others will be filled with NA


brks <- c( 0, 35, 45, 55, 85, 95, 150)
nb <- length(brks) - 1
cols <- colorRampPalette(c("dark green", "green", "light green", "yellow", "orange", "red", "black" )) (nb)

# use gplot from the rastervis package

  gplot(lc_c_mwi_rcl, maxpixels = 50000) + 
    geom_tile(aes(fill = value), alpha = 1) +
  geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
    scale_fill_gradientn( colours = cols,
                       na.value = NA) +
    labs(fill = "-------------\nCopernicus\nLand Cover\nReclassified\n-------------") +
    theme(
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank()
    )



```



### Roads


```{r osm_2_postgres, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "OSM Roads", dev = 'png', results='hide'}

# OSM file pre-downloaded for Central Malawi
# Lines exported from QGIS to geojson format

## ---- RUN THIS ONCE ----
#osm_malawi_lines <- st_read("D:/repos/database_connect/data/inputs/osm_lines.geojson")
#osm_malawi_lines_utm <-st_transform(osm_malawi_lines, 32736)

# this writes the boundary to postgres

#st_write(obj = osm_malawi_lines_utm, dsn = con, Id(schema="coverage", table = "osm_malawi_lines_utm"))


```


```{r roads_osm, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "OSM Roads", dev = 'png', results='hide'}

# query to select trunk roads
qry <- sprintf(
  "SELECT  osm_id, name, highway, geometry 
                FROM COVERAGE.osm_malawi_lines_utm
  WHERE highway = 'trunk' OR highway = 'trunk_link' OR highway = 'primary' OR highway = 'primary_link'"
)

# fetch data from db, 
trunk_geo <- dbGetQuery(con, qry)

# https://stackoverflow.com/questions/58398074/import-csv-with-postgres-geometry-column-as-sf

#1. convert the geometry strings to sf spatial objects:
newGeom <- st_as_sfc(structure(as.character(trunk_geo$geom), class = "WKB"),EWKB=TRUE)

#2. create a new spatial data frame with the new spatial objects as geometry
trunk_geo_sdf <- st_set_geometry(trunk_geo, newGeom)

#3. (optional) drop the character format column
trunk_geo_sdf$geom=NULL
st_crs(trunk_geo_sdf, 4236)
trunk_utm_sdf <- st_transform(trunk_geo_sdf, 32736)
trunk_utm_sdf_central <- st_intersection(central_mask, trunk_utm_sdf)



# query to select secondary roads
qry <- sprintf(
  "SELECT  osm_id, name, highway, geometry 
                FROM COVERAGE.osm_malawi_lines_utm
  WHERE highway = 'secondary' OR highway = 'secondary_link' OR highway = 'tertiary' OR highway = 'tertiary_link' "
)

# fetch data from db, 
secondary_geo <- dbGetQuery(con, qry)

# https://stackoverflow.com/questions/58398074/import-csv-with-postgres-geometry-column-as-sf

#1. convert the geometry strings to sf spatial objects:
newGeom <- st_as_sfc(structure(as.character(secondary_geo$geom), class = "WKB"),EWKB=TRUE)

#2. create a new spatial data frame with the new spatial objects as geometry
secondary_geo_sdf <- st_set_geometry(secondary_geo, newGeom)

#3. (optional) drop the character format column
secondary_geo_sdf$geom=NULL
st_crs(secondary_geo_sdf, 4236)
secondary_utm_sdf <- st_transform(secondary_geo_sdf, 32736)
secondary_utm_sdf_central <- st_intersection(central_mask, secondary_utm_sdf)

# query to select other roads
qry <- sprintf(
  "SELECT  osm_id, name, highway, geometry 
                FROM COVERAGE.osm_malawi_lines_utm
  WHERE  highway = 'track' OR highway = 'residential'"
)

# fetch data from db, 
other_geo <- dbGetQuery(con, qry)

# https://stackoverflow.com/questions/58398074/import-csv-with-postgres-geometry-column-as-sf

#1. convert the geometry strings to sf spatial objects:
newGeom <- st_as_sfc(structure(as.character(other_geo$geom), class = "WKB"),EWKB=TRUE)

#2. create a new spatial data frame with the new spatial objects as geometry
other_geo_sdf <- st_set_geometry(other_geo, newGeom)

#3. (optional) drop the character format column
other_geo_sdf$geom=NULL
st_crs(other_geo_sdf, 4236)
other_utm_sdf <- st_transform(other_geo_sdf, 32736)
other_utm_sdf_central <- st_intersection(central_mask, other_utm_sdf)


roads_utm_plot <- ggplot() +
  geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_sf(data = other_utm_sdf_central, colour = 'yellow') +
  geom_sf(data = secondary_utm_sdf_central, colour = 'orange') +
  geom_sf(data = trunk_utm_sdf_central, colour = 'red' ) +
  geom_sf(data = cnfa_ag_dealers_sdf, colour = 'green', size = 1, shape = 3)

roads_utm_plot

```

```{r vehicle_time, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "OSM Roads - Time to travel 1km in vehicle", dev = 'png', results='hide'}

# Create a raster from the roads giving a value of time to cross the cell in seconds

# Assume velocity of 60km/hr for trunk and primary roads
# Assume velocity of 30km/hr for secondary and tertiary roads
# Assume velocity of 10km/hr for other roads

# terra rasterize is considerably faster than raster rasterize so convert all vector and raster inputs

r_roads_t_v <- terra::rasterize(vect(trunk_utm_sdf_central), rast(mask_raster), 60)
r_roads_s_v <- terra::rasterize(vect(secondary_utm_sdf_central), rast(mask_raster), 120)
r_roads_o_v <- terra::rasterize(vect(other_utm_sdf_central), rast(mask_raster), 360)

roads_comb_v <- raster::raster(terra::merge(r_roads_t_v, merge(r_roads_s_v, r_roads_o_v)))
roads_comb_v

gplot(roads_comb_v, maxpixels = 100000) +
  geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_tile(aes(fill = value), alpha = 1) +
  
    scale_fill_gradient(low = 'red',
                        high = 'yellow', 
                        na.value = NA) +
  #xlim(-20, 60) +
  #ylim(-40, 40) +
  labs(fill = "-------------\nTime\nVehicles\n-------------") +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

```

```{r bicycle_time, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "OSM Roads - Time to travel 1km on bicycle", dev = 'png', results='hide'}

# Create a raster from the roads giving a value of time to cross the cell in seconds

# Assume velocity of 15 km/hr for trunk and primary roads
# Assume velocity of 10 km/hr for secondary and tertiary roads
# Assume velocity of 10 km/hr for other roads

# terra rasterize is considerably faster than raster rasterize so convert all vector and raster inputs

r_roads_t_b <- terra::rasterize(vect(trunk_utm_sdf_central), rast(mask_raster), 240)
r_roads_s_b <- terra::rasterize(vect(secondary_utm_sdf_central), rast(mask_raster), 360)
r_roads_o_b <- terra::rasterize(vect(other_utm_sdf_central), rast(mask_raster), 360)

roads_comb_b <- raster::raster(terra::merge(r_roads_t_b, merge(r_roads_s_b, r_roads_o_b)))
roads_comb_b

gplot(roads_comb_b, maxpixels = 100000) +
  geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_tile(aes(fill = value), alpha = 1) +
  
    scale_fill_gradient(low = 'red',
                        high = 'yellow', 
                        na.value = NA) +
  #xlim(-20, 60) +
  #ylim(-40, 40) +
  labs(fill = "-------------\nTime\nBicycles\n-------------") +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

```


```{r walking_time, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "OSM Roads - Time to travel 1km on foot", dev = 'png', results='hide'}

# Create a raster from the roads giving a value of time to cross the cell in seconds

# Assume velocity of 5 km/hr for trunk and primary roads
# Assume velocity of 5 km/hr for secondary and tertiary roads
# Assume velocity of 5 km/hr for other roads

# terra rasterize is considerably faster than raster rasterize so convert all vector and raster inputs

r_roads_t_w <- terra::rasterize(vect(trunk_utm_sdf_central), rast(mask_raster), 720)
r_roads_s_w <- terra::rasterize(vect(secondary_utm_sdf_central), rast(mask_raster), 720)
r_roads_o_w <- terra::rasterize(vect(other_utm_sdf_central), rast(mask_raster), 720)

roads_comb_w <- raster::raster(terra::merge(r_roads_t_w, merge(r_roads_s_w, r_roads_o_w)))
roads_comb_w

gplot(roads_comb_w, maxpixels = 100000) +
  geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_tile(aes(fill = value), alpha = 1) +
  
    scale_fill_gradient(low = 'red',
                        high = 'yellow', 
                        na.value = NA) +
  #xlim(-20, 60) +
  #ylim(-40, 40) +
  labs(fill = "-------------\nTime\nWalking\n-------------") +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

```


### Land, Roads and Slope Combined



```{r vehicle_friction, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Vehicular Friction surface", dev = 'png', results='hide'}

f <- function(x,y) ifelse(is.na(x), y, x)
lc_ro_v <- overlay(roads_comb_v, lc_c_mwi_rcl, fun = f)
lc_ro_v


### compute vehicular friction surface
f1 <- function(x,y) x/(exp(-3*y))  
friction_v <- overlay(lc_ro_v, slope_c_mwi, fun = f1)
friction_v

gplot(friction_v, maxpixels = 100000) +
  geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_tile(aes(fill = value), alpha = 1) +
      scale_fill_gradientn( colours = cols,
                       na.value = NA, limits = c(0,3600)) +
  labs(fill = "-------------\nFriction\nSurface\nVehicles\n-------------") +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )


```

```{r bicycle_friction, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Bicycle Friction surface", dev = 'png', results='hide'}

f <- function(x,y) ifelse(is.na(x), y, x)
lc_ro_b <- overlay(roads_comb_b, lc_c_mwi_rcl, fun = f)
lc_ro_b


### compute vehicular friction surface
f1 <- function(x,y) x/(exp(-3*y))  
friction_b <- overlay(lc_ro_b, slope_c_mwi, fun = f1)
friction_b

gplot(friction_b, maxpixels = 100000) +
  geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_tile(aes(fill = value), alpha = 1) +
      scale_fill_gradientn( colours = cols,
                       na.value = NA, limits = c(0,3600)) +
  labs(fill = "-------------\nFriction\nSurface\nBicycles\n-------------") +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )


```


```{r walking_friction, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Walking Friction surface", dev = 'png', results='hide'}

f <- function(x,y) ifelse(is.na(x), y, x)
lc_ro_w <- overlay(roads_comb_w, lc_c_mwi_rcl, fun = f)
lc_ro_w


### compute vehicular friction surface
f1 <- function(x,y) x/(exp(-3*y))  
friction_w <- overlay(lc_ro_w, slope_c_mwi, fun = f1)
friction_w

gplot(friction_w, maxpixels = 100000) +
  geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_tile(aes(fill = value), alpha = 1) +
      scale_fill_gradientn( colours = cols,
                       na.value = NA, limits = c(0,3600)) +
  labs(fill = "-------------\nFriction\nSurface\nWalking\n-------------") +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )


```

```{r friction_2_postgres, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "OSM Roads", dev = 'png', results='hide'}



# this writes the friction surfaces to postgres

# vehicle friction points
temp_points <- st_as_sf(rasterToPoints(friction_v, spatial=TRUE))
temp_points$id <- seq.int(nrow(temp_points))

st_write(obj = temp_points, dsn = con, Id(schema="coverage", table = "friction_v_points"))

# bicycle friction points
temp_points <- st_as_sf(rasterToPoints(friction_b, spatial=TRUE))
temp_points$id <- seq.int(nrow(temp_points))

st_write(obj = temp_points, dsn = con, Id(schema="coverage", table = "friction_b_points"))

# bicycle friction raster
temp_polys <- st_as_sf(rasterToPolygons(friction_b))
temp_polys$id <- seq.int(nrow(temp_polys))

st_write(obj = temp_polys, dsn = con, Id(schema="coverage", table = "friction_b_raster_edges"))

temp_points <- distinct(dplyr::select(st_cast(st_as_sf(rasterToPolygons(friction_b)), "POINT"), -layer))
temp_points$id <- seq.int(nrow(temp_points))

st_write(obj = temp_points, dsn = con, Id(schema="coverage", table = "friction_b_raster_vertices"))




# walking friction points
temp_points <- st_as_sf(rasterToPoints(friction_w, spatial=TRUE))
temp_points$id <- seq.int(nrow(temp_points))

st_write(obj = temp_points, dsn = con, Id(schema="coverage", table = "friction_w_points"))


```

## Get the population grid

```{r population_grid, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Population - Central Region Malawi", dev = 'png', results='hide'}


# WorldPop 2020 constrained data available at: DOI : 10.5258/SOTON/WP00682

pop_mwi <- crop(raster("D:/DatosProyecto/SpatialData/Africa/Pais/Malawi/WorldPop/mwi_ppp_2020_constrained.tif"), extent(c(30, 36, -20, -10))) 
pop_mwi

crs_32736 <- sp::CRS(wkt_32736)

pop_mwi_utm  <- projectRaster(pop_mwi, crs = crs_32736, res=100)
pop_mwi_utm

pop_mwi_utm_agg <- aggregate(pop_mwi_utm, fact=10, fun=sum)
pop_mwi_utm_agg


pop_mwi_utm_rsmp  <- resample(pop_mwi_utm_agg, mask_raster, method="ngb")
pop_mwi_utm_rsmp

pop_mask_raster <- rasterize(boundary_mcr_utm, blank_raster, field=1)
pop_mask_raster

pop_mwi_utm_rsmp  <- pop_mwi_utm_rsmp * pop_mask_raster
pop_mwi_utm_rsmp

pop_mwi_utm_rsmp_df <- gplot_data(pop_mwi_utm_rsmp) # convert to geom_tile type of raster
# multiple geom_tiles can be incorporated in a conventional ggplot

pop_mwi_utm_rsmp_df

total_pop <- cellStats(pop_mwi_utm_rsmp,stat='sum')
cat("Total Population = ", total_pop)
target_pop <- total_pop * 0.8
cat("Target Population = ", target_pop)

gplot(pop_mwi_utm_rsmp, maxpixels = 100000) +
  geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_tile(aes(fill = value), alpha = 1) +
  
    scale_fill_gradient(low = 'yellow',
                        high = 'red', 
                        na.value = NA) +
  #xlim(-20, 60) +
  #ylim(-40, 40) +
  labs(fill = "-------------\nPopulation\nper 1km\ngrid cell\n-------------") +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )


```

```{r pop_2_postgres, cache=TRUE, results='hide'}


# this writes the pop surface to postgres

temp_points <- st_as_sf(rasterToPoints(pop_mwi_utm_rsmp, spatial=TRUE))
temp_points$Id <- seq.int(nrow(temp_points))

st_write(obj = temp_points, dsn = con, Id(schema="coverage", table = "pop_mwi_points"))


```

## Vehicle accessibility analysis with existing agro-dealers

### Total Time

```{r vehicle_access_existing, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Vehicle Accessibility - Existing Agro-Dealers", dev = 'png', results='markup'}


tr_v <- transition(friction_v,function(x) 1/mean(x), 8) # transition from vehicle friction
tr_v <- geoCorrection(tr_v, scl = TRUE) # Geographic correction is necessary for all objects of the class Transition that are made with directions > 4.The function will correct for diagonal connections between grid cells (which cover a longer distance than vertical or horizontal connections).


cnfa_ag_dealers_sp <- as_Spatial(cnfa_ag_dealers_sdf)

cnfa_cost_v <- accCost(tr_v, cnfa_ag_dealers_sp)

gplot(cnfa_cost_v, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
    geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_sf(data = cnfa_ag_dealers_sdf, colour = 'dark green', size = 0.5, shape = 3,
      inherit.aes = FALSE) +
  scale_fill_gradient(low = 'yellow',
                        high = 'red', 
                        na.value = NA, limits = c(0,10000)) +
  
  xlim(450000, 725000) +
  ylim(8300000, 8650000) +
  labs(fill = "-------------\nTime to\nNGO\nAgro-\nDealers\nVehicles\n-------------") +
  
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

```
### Within 1 hour

```{r vehicle_access_existing_1hr, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Within 1 hour - Vehicle Accessibility - Existing Agro-Dealers", dev = 'png', results='markup'}

r_cnfa_1hr_v <-  reclassify(cnfa_cost_v, matrix(c(-Inf, 3600, 1, 3600, Inf, 0),
                                    ncol = 3,
                                    byrow = TRUE))

gplot(r_cnfa_1hr_v, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
    geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_sf(data = cnfa_ag_dealers_sdf, colour = 'dark green', size = 0.5, shape = 3,
      inherit.aes = FALSE) +
  scale_fill_gradient(low = 'yellow',
                        high = 'red', 
                        na.value = NA, limits = c(1,1)) +
  
  xlim(450000, 725000) +
  ylim(8300000, 8650000) +
  labs(fill = "-------------\nWithin\n1 hour of\nNGO\nAgro-\nDealers by\nVehicles\n-------------") +
  
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

r_cnfa_pop_v <- r_cnfa_1hr_v * pop_mwi_utm_rsmp
cnfa_pop_v <- cellStats(r_cnfa_pop_v, stat='sum')
cat("Total Population within 1 hour of Existing Agro-Dealers by Vehicles = ", cnfa_pop_v,"\n\n")

if (cnfa_pop_v < target_pop) {
  run_heuristic_v <- TRUE
  cat("Target Population not reached. Run the heuristic for potential agro-dealers")
  
} else {
  run_heuristic_v <- FALSE
  cat("Target Population reached. Do not run the heuristic for potential agro-dealers")
}

```

## Vehicle greedy add heuristic with potential agro-dealers

If the target population is not reached by the existing Existing agro-dealers then I need to consider the other potential agro-dealers.

Before running the greedy add heuristic I need to check whether it is possible to reach 80% of the population from the other potential agro-dealer locations.


### Remaining Population

```{r vehicle_remaining_population, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Vehicle Accessibility - Remaining Population", dev = 'png', results='markup'}

if ( run_heuristic_v == TRUE) {
 

  r_covered_pop_v <- r_cnfa_pop_v
  
  # remove the already covered population from the population grid to give remaining value
  r_remaining_pop_v <- pop_mwi_utm_rsmp - r_cnfa_pop_v
  
  # reclassify to show the area already covered as NA 
  r_remaining_pop_v_rcl  <-
    reclassify(r_remaining_pop_v, matrix(c(0, NA),
                                         ncol = 2,
                                         byrow = TRUE))
  
  r_remaining_pop_v_df <- gplot_data(r_remaining_pop_v_rcl)  # convert to geom_tile type of raster

remaining_pop_v_plot <- gplot(r_remaining_pop_v, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
    geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_sf(
    data = cnfa_ag_dealers_sdf,
    colour = 'dark green',
    size = 0.5,
    shape = 3,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = pot_ag_dealers_sdf,
    colour = 'blue',
    size = 0.5,
    shape = 1,
    inherit.aes = FALSE
  ) +
  scale_fill_gradient(
    low = 'yellow',
    high = 'red',
    na.value = NA,
    limits = c(0.5, 5000)
  ) +
  
  xlim(450000, 725000) +
  ylim(8300000, 8650000) +
  labs(fill = "-------------\nRemaining\nPopulation\nVehicles\n-------------") +
  
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

print(remaining_pop_v_plot)

diff_pop_v <- cellStats(r_remaining_pop_v,stat='sum')
cat("Target Population = ", formatC(target_pop, format="d", big.mark=","),"\n\n")
cat("Total Population within 1 Hour = ", formatC(cnfa_pop_v, format="d", big.mark=","),"\n\n")
cat("Total Uncovered Population = ", formatC(diff_pop_v, format="d", big.mark=","),"\n\n")
cat("Remaining Population to Target = ", formatC((target_pop - cnfa_pop_v), format="d", big.mark=","),"\n\n")

potential_pop_v <- 0

}

```

```{r pop_rem_v_2_postgres, cache=TRUE, results='hide'}

if ( run_heuristic_v == TRUE) {
# this writes the  remaining pop surface to postgres

temp_points <- st_as_sf(rasterToPoints(r_remaining_pop_v, function(x){x>0}, spatial=TRUE))
temp_points$Id <- seq.int(nrow(temp_points))

st_write(obj = temp_points, dsn = con, Id(schema="coverage", table = "remaining_pop_v_points"))
}

```


### Total Time

```{r vehicle_access_potential, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Vehicle Accessibility - Potential Agro-Dealers", dev = 'png', results='hide'}

if ( run_heuristic_v == TRUE) {
  
pot_ag_dealers_sp <- as_Spatial(pot_ag_dealers_sdf)

pot_cost_v <- accCost(tr_v, pot_ag_dealers_sp)

access_pot_v_plot <- gplot(pot_cost_v, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
      geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_sf(
    data = pot_ag_dealers_sdf,
    ,
    colour = 'blue',
    size = 0.5,
    shape = 1,
    inherit.aes = FALSE
  ) +
  scale_fill_gradient(low = 'yellow',
                        high = 'red', 
                        na.value = NA, limits = c(0,10000)) +
  
  xlim(450000, 725000) +
  ylim(8300000, 8650000) +
  labs(fill = "-------------\nTime to\nnon-NGO\nPotential\nAgro-\nDealers\nVehicles\n-------------") +
  
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

print(access_pot_v_plot)

}

```

### Within 1 hour

```{r vehicle_access_potential_1hr, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Within 1 hour - Vehicle Accessibility - Potential Agro-Dealers", dev = 'png', results='markup'}

if (run_heuristic_v == TRUE) {
  r_pot_1hr_v <-
    reclassify(pot_cost_v, matrix(c(-Inf, 3600, 1, 3600, Inf, 0),
                                  ncol = 3,
                                  byrow = TRUE))
  
  access_1hr_pot_v_plot <-   gplot(r_pot_1hr_v, maxpixels = 50000) +
    geom_tile(aes(fill = value), alpha = 1) +
        geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
    geom_sf(
      data = pot_ag_dealers_sdf,
      colour = 'blue',
      size = 0.5,
      shape = 1,
      inherit.aes = FALSE
    ) +
    scale_fill_gradient(
      low = 'yellow',
      high = 'red',
      na.value = NA,
      limits = c(1, 1)
    ) +
    
    xlim(450000, 725000) +
    ylim(8300000, 8650000) +
    labs(fill = "-------------\nWithin\n1 hour of\nnon-NGO\nPotential\nAgro-\nDealers by\nVehicles\n-------------") +
    
    theme(
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank()
    )
  
  print(access_1hr_pot_v_plot)
  r_pot_pop_v <- r_pot_1hr_v * r_remaining_pop_v
  pot_pop_v <- cellStats(r_pot_pop_v, stat = 'sum')
  cat(
    "Total Population within 1 hour of New Agro-Dealers by Vehicles (excluding population already covered by Existing Agro-Dealers) = ",
    pot_pop_v, "\n\n"
  )
  cnfa_pot_pop_v <- (cnfa_pop_v +  pot_pop_v)
  cat(
    "Total Population within 1 hour of both Existing and New Agro-Dealers by Vehicles = ",
    cnfa_pot_pop_v, "\n\n"
  )
    cat(
    "Target Population within 1 hour of both Existing and New Agro-Dealers by Vehicles = ",
    target_pop, "\n\n"
  )
  
  if (cnfa_pot_pop_v < target_pop) {
    run_heuristic_v <- FALSE
    cat(
      "Target Population still not reached. Do not run the heuristic for potential agro-dealers"
    )
    
  } else {
    run_heuristic_v <- TRUE
    cat("Target Population can be reached. Run the heuristic for potential agro-dealers")
  }
}

```

### Heuristic

```{r vehicle_g_add_potential, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Vehicle Accessibility - Potential Agro-Dealers", dev = 'png', results='markup'}


if (run_heuristic_v == TRUE) {
  # ----CREATE A TEMP DATAFRAME OF POINTS WITH ID GEOMETRY AND (EMPTY) pop1hr FIELD----
  
  temp_pot <- dplyr::select(pot_ag_dealers_sdf, id)
  temp_pot$pop1hr_v <- 0
  temp_pot_sp_v <-
    as_Spatial(temp_pot) # convert to sp for AccCost function
  
  # -----create a vector to store id of maxpop points-----
  
  highpop_pt_v <- c()
  
  # ----create an empty data frame of optimum points with attributes
  
  highpop_df_v <-
    data.frame(
      'id' = integer(),
      'pop_cap_j' = integer(),
      'iteration' = integer(),
      'pop_cap_tot' = integer()
    )
  
  
  # ----start loops----
  
  j = 0 # counter for number of iterations
  
  # ----PLOT START MAP AND CHARTS ----
  # ----plot the start map----
  
  access_g_add_1hr_pot_v_plot <- ggplot() +
    geom_sf(
      data = boundary_mcr_utm,
      fill = 'grey',
      col = NA,
      na.rm = TRUE,
      inherit.aes = FALSE
    ) +
    geom_tile(data = pop_mwi_utm_rsmp_df,
              aes(x = x, y = y, fill = value)) +
    geom_tile(
      data = dplyr::filter(r_remaining_pop_v_df, !is.na(value)),
      aes(x = x, y = y),
      fill = "grey20",
      alpha = 0.5
    )   +
    geom_tile(
      data = dplyr::filter(lc_c_mwi_rcl_water_df, !is.na(value)),
      aes(x = x, y = y),
      fill = "blue",
      alpha = 0.5
    )   +
    geom_sf(
      data = central_mask,
      fill = NA,
      col = 'dark grey',
      na.rm = TRUE,
      inherit.aes = FALSE
    ) +
    geom_sf(
      data = boundary_mcr_utm,
      fill = NA,
      colour = 'grey20',
      size = 1.5,
      inherit.aes = FALSE
    ) +
    geom_sf(
      data = boundary_mcr_dist_utm,
      fill = NA,
      colour = 'grey20',
      size = 0.75,
      inherit.aes = FALSE
    )    +
    geom_sf(
      data = cnfa_ag_dealers_sdf,
      colour = 'dark green',
      size = 1,
      aes(shape = "Existing"),
      inherit.aes = FALSE
    ) +
    geom_text(
      x = 660000,
      y = 8320000 ,
      aes(
        label = paste0(
          "Population within 1 Hour: ",
          formatC((cnfa_pop_v),
                  format = "d",
                  big.mark = ",")
        ),
        hjust = 'right'
      ),
      size = 4,
      colour = 'dark green'
    ) +
    geom_text(
      x = 660000,
      y = 8340000 ,
      aes(
        label = paste0("Target Population: ", formatC((target_pop),
                                                      format = "d",
                                                      big.mark = ","
        )),
        hjust = 'right'
      ),
      size = 4,
      colour = 'blue'
    ) +
    geom_text(
      x = 660000,
      y = 8360000 ,
      aes(label = paste0(j,  " New Agro-Dealers"),
          hjust = 'right'),
      size = 4,
      colour = 'black'
    ) +
    scale_shape_manual(name = "Agro-Dealers", values = c("Existing" = 3, "New" =
                                                           1)) +
    #scale_colour_manual(name = "", values = c("Existing" = "dark green", "New" = "blue")) +
    scale_fill_gradient(
      labels = comma,
      low = 'yellow',
      high = 'red',
      na.value = NA,
      limits = c(0.5, 10000)
    ) +
    scale_x_continuous(expand = c(0, 0),
                       limits = c(455000, 720000)) +
    scale_y_continuous(expand = c(0, 0),
                       limits = c(8305000, 8655000)) +
    labs(fill = expression(
      paste(
        "-------------\nPopulation\nWithin\n1 Hour\n-------------\npersons/km" ^
          2
      )
    )) +
    theme(
      #panel.background = element_rect(fill = 'white'),
      #panel.grid.major.x = element_blank(),
      #panel.grid.major.x = element_line(colour = 'grey'),
      #panel.grid.minor.x = element_blank(),
      panel.grid.minor.x = element_line(colour = 'grey'),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      panel.background = element_rect(fill = 'white', color = NA),
      panel.grid.major = element_line(color = 'grey', linetype = 'dotted'),
      panel.grid.minor = element_line(color = 'green', size = 2),
      legend.key = element_rect(fill = 'white')
    ) +
    guides(fill = guide_colourbar(order = 1),
           shape = guide_legend(order = 2))
  
  ## ----add a dummy point for plotting bar graph----
  crs <- st_crs(32736)
  dummy_point <- st_sf(
    id = NA,
    pop1hr_v = 0,
    pop_cap_j = 0,
    iteration = 0,
    pop_cap_tot = cnfa_pop_v,
    geometry = st_sfc(st_point(0:1)),
    crs = crs
  )
  
  ## ----plot the start bar chart----
  
  covered_population_plot <- ggplot(dummy_point) +
    geom_bar(aes(
      x = iteration,
      y = pop_cap_tot,
      alpha = (iteration / j)
    ),
    stat = 'identity',
    fill = 'dark green') +
    geom_point(aes(iteration, pop_cap_tot)) +
    geom_hline(
      yintercept = (target_pop),
      linetype = 'dashed',
      color = 'blue'
    ) +
    geom_text(
      x = 0,
      y =  target_pop - ((target_pop / 100) * 2.5),
      aes(label = "Target Population",
          hjust = 'left'),
      size = 4,
      colour = 'blue'
    ) +
    scale_alpha_continuous(guide = 'none') +
    scale_y_continuous(expand = c(0, 0),
                       labels = comma,
                       limits = c(0, max(
                         c(target_pop),
                         max(dummy_point$pop_cap_tot)
                       ))) +
    scale_x_continuous(
      expand = c(0, 0),
      labels = label_number(accuracy = 1),
      limits = c(0, (j + 1))#,
      #breaks = round(seq(0, j)),
      #1
    ) +
    labs(x = "New Agro-Dealers (#)", y = "Population within 1 Hour (#)") +
    theme(
      #panel.grid.major.x = element_blank(),
      #panel.grid.minor.x = element_blank(),
      #axis.title.x = element_blank(),
      axis.title.x = element_text(colour = 'grey20'),
      axis.title.y = element_text(colour = 'grey20'),
      axis.text.y = element_text(angle = 45),
      panel.background = element_rect(fill = 'white', color = NA),
      panel.grid.major.y = element_line(color = 'grey', linetype = 'dotted')
    )
  
  # ----combine map and bar chart ----
  
  
  access_covered <-
    plot_grid(
      access_g_add_1hr_pot_v_plot,
      covered_population_plot,
      align = "h",
      axis = "bt",
      rel_widths = c(1.3, 1)
    )
  
  
  # ----save combined plots as png ----
  ggsave(
    file = paste0("charts/access_g_add_1hr_pot_v_plot_", j, ".png"),
    plot = access_covered,
    width = 10,
    height = 5,
    units = "in",
    dpi = 300
  )
  
  # files uploaded to https://ezgif.com/ for animated gif
  
  # ----while target population not covered----
  
  while ((cnfa_pop_v + potential_pop_v) < target_pop) {
    j = j + 1
    
    
    # ----for every point in the temporary sp data frame----
    
    
    for (i in 1:length(temp_pot_sp_v)) {
      #print(j) # for debugging purposes
      
      # ----RUN COSTDISTANCE USING FRICTION GRID AND NEW TARGET POINT----
      acc_i_v <-
        accCost(tr_v, temp_pot_sp_v[i, ]) %>%
        reclassify(matrix(c(-Inf, 3600, 1, 3600, Inf, 0)))
      
      # ----multiply hour cost grid with remaining population get sum and add value to temporary sp data frame pop1hr_v field ----
      
      popsum_i_v <- (acc_i_v * r_remaining_pop_v)  %>%
        cellStats(stat = 'sum')
      
      temp_pot_sp_v[i, 2] <- popsum_i_v
      
    }
    
    # ----finish for loop----
    
    
    # ----COMPARE total_pop AND RECORD POINT-ID----
    
    # the index of the point with the maximum population covered
    highpop_index_v <- which.max(temp_pot_sp_v$pop1hr_v)
    print(paste(
      "Index of the point with the maximum population covered is : ",
      which.max(temp_pot_sp_v$pop1hr_v)
    ))
    
    # the id of the point with the maximum population covered using the index
    highpop_id_v <- temp_pot_sp_v$id[[highpop_index_v]]
    print(paste(
      "Id of the point with the maximum population covered is : ",
      highpop_id_v
    ))
    
    # the maximum population covered using the index
    print(paste(
      "Maximum population covered is : ",
      max(temp_pot_sp_v$pop1hr_v)
    ))
    
    # ----save the point with the maximum population covered in vector----
    
    highpop_pt_v <- append(highpop_pt_v, highpop_id_v)
    
    
    # ----RERUN THE COSTDISTANCE FOR THE OPTIMUM POINT , SAVE AND DISCARD----
    
    # using saved index
    
    acc_high_v <- accCost(tr_v, temp_pot_sp_v[highpop_index_v,]) %>%
      reclassify(matrix(c(-Inf, 3600, 1, 3600, Inf, 0)))
    
    # ----multiply hour cost grid with remaining population get sum ----
    
    popsum_high_v <- (acc_high_v * r_remaining_pop_v)
    potential_pop_i_v <- cellStats(popsum_high_v, stat = 'sum')
    cat(
      "Total Population within 1 hour of number",
      j ,
      " New Potential Agro-Dealer = ",
      potential_pop_i_v,
      "\n\n"
    )
    cat(
      "Total Population within 1 hour of all ",
      j ,
      " New Potential Agro-Dealers = ",
      (cnfa_pop_v + potential_pop_v + potential_pop_i_v),
      "\n\n"
    )
    
    # ----update population sums----
    
    # update covered population
    potential_pop_v <- potential_pop_i_v + potential_pop_v
    
    # update remaining population rasters
    r_remaining_pop_v <- r_remaining_pop_v - popsum_high_v
    
    # reclassify to show the area already covered as NA
    r_remaining_pop_v_rcl  <-
      reclassify(r_remaining_pop_v, matrix(c(0, NA),
                                           ncol = 2,
                                           byrow = TRUE))
    
    r_remaining_pop_v_df <-
      gplot_data(r_remaining_pop_v_rcl)  # convert to geom_tile type of raster
    
    
    # update remaining population
    diff_pop_v <- cellStats(r_remaining_pop_v, stat = 'sum')
    cat("Total Remaining Possible Population = ", diff_pop_v, "\n\n")
    cat(
      "Target Remaining Population = ",
      (target_pop - cnfa_pop_v - potential_pop_v),
      "\n\n"
    )
    
    # ----create a data frame of optimum points with attributes and inner-join to temporary points for mapping
    
    highpop_df_v <-
      rbind(
        highpop_df_v,
        data.frame(
          'id' = as.integer(highpop_id_v),
          'pop_cap_j' = as.integer(potential_pop_i_v),
          'iteration' = as.integer(j),
          'pop_cap_tot' = as.integer(cnfa_pop_v + potential_pop_v)
        )
      )
    
    new_pts_v <- inner_join(temp_pot, highpop_df_v, by = 'id')
    
    # ----remove latest optimum point from temp_pot_sp_v to reduce burden
    
    temp_pot_sp_v <- temp_pot_sp_v[-c(highpop_index_v), ]
    
    # ----PRODUCE MAP OF CAPTURED POPULATION AND BARCHART OF THIS ITERATION OF WHILE LOOP----
    
    # ----plot the map----
    
    access_g_add_1hr_pot_v_plot <- ggplot() +
      geom_sf(
        data = boundary_mcr_utm,
        fill = 'grey',
        col = NA,
        na.rm = TRUE,
        inherit.aes = FALSE
      ) +
      geom_tile(data = pop_mwi_utm_rsmp_df,
                aes(x = x, y = y, fill = value)) +
      geom_tile(
        data = dplyr::filter(r_remaining_pop_v_df,!is.na(value)),
        aes(x = x, y = y),
        fill = "grey20",
        alpha = 0.5
      )   +
      geom_tile(
        data = dplyr::filter(lc_c_mwi_rcl_water_df,!is.na(value)),
        aes(x = x, y = y),
        fill = "blue",
        alpha = 0.5
      )   +
      geom_sf(
        data = central_mask,
        fill = NA,
        col = 'dark grey',
        na.rm = TRUE,
        inherit.aes = FALSE
      ) +
      geom_sf(
        data = boundary_mcr_utm,
        fill = NA,
        colour = 'grey20',
        size = 1.5,
        inherit.aes = FALSE
      ) +
      geom_sf(
        data = boundary_mcr_dist_utm,
        fill = NA,
        colour = 'grey20',
        size = 0.75,
        inherit.aes = FALSE
      )    +
      geom_sf(
        data = cnfa_ag_dealers_sdf,
        colour = 'dark green',
        size = 1,
        aes(shape = "Existing"),
        inherit.aes = FALSE
      ) +
      geom_sf(
        data = new_pts_v,
        colour = 'dark green',
        size = 1,
        aes(shape = "New"),
        inherit.aes = FALSE
      ) +
      geom_text(
        x = 660000,
        y = 8320000 ,
        aes(
          label = paste0(
            "Population within 1 Hour: ",
            formatC((potential_pop_v + cnfa_pop_v),
                    format = "d",
                    big.mark = ","
            )
          ),
          hjust = 'right'
        ),
        size = 4,
        colour = 'dark green'
      ) +
      geom_text(
        x = 660000,
        y = 8340000 ,
        aes(
          label = paste0("Target Population: ", formatC((target_pop),
                                                        format = "d",
                                                        big.mark = ","
          )),
          hjust = 'right'
        ),
        size = 4,
        colour = 'blue'
      ) +
      geom_text(
        x = 660000,
        y = 8360000 ,
        aes(label = paste0(j, " New Agro-Dealers"),
            hjust = 'right'),
        size = 4,
        colour = 'black'
      ) +
      scale_shape_manual(name = "Agro-Dealers",
                         values = c("Existing" = 3, "New" = 1)) +
      scale_fill_gradient(
        labels = comma,
        low = 'yellow',
        high = 'red',
        na.value = NA,
        limits = c(0.5, 10000)
      ) +
      scale_x_continuous(expand = c(0, 0),
                         limits = c(455000, 720000)) +
      scale_y_continuous(expand = c(0, 0),
                         limits = c(8305000, 8655000)) +
      labs(fill = expression(
        paste(
          "-------------\nPopulation\nWithin\n1 Hour\n-------------\npersons/km" ^
            2
        )
      )) +
      theme(
        #panel.background = element_rect(fill = 'white'),
        #panel.grid.major.x = element_blank(),
        #panel.grid.major.x = element_line(colour = 'grey'),
        #panel.grid.minor.x = element_blank(),
        panel.grid.minor.x = element_line(colour = 'grey'),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_rect(fill = 'white', color = NA),
        panel.grid.major = element_line(color = 'grey', linetype = 'dotted'),
        panel.grid.minor = element_line(color = 'green', size = 2),
        legend.key = element_rect(fill = 'white')
      ) +
      guides(fill = guide_colourbar(order = 1),
             shape = guide_legend(order = 2))
    
    ## ----add a dummy point for plotting bar graph----
    crs <- st_crs(32736)
    dummy_point <- st_sf(
      id = NA,
      pop1hr_v = 0,
      pop_cap_j = 0,
      iteration = 0,
      pop_cap_tot = cnfa_pop_v,
      geometry = st_sfc(st_point(0:1)),
      crs = crs
    )
    
    new_pts_v_dummy <- rbind(new_pts_v, dummy_point)
    
    ## ----plot the bar chart----
    
    covered_population_plot <- ggplot(new_pts_v_dummy) +
      geom_bar(aes(
        x = iteration,
        y = pop_cap_tot,
        alpha = (iteration / j)
      ),
      stat = 'identity',
      fill = 'dark green',) +
      geom_point(aes(iteration, pop_cap_tot)) +
      geom_hline(
        yintercept = (target_pop),
        linetype = 'dashed',
        color = 'blue'
      ) +
      geom_text(
        x = 0,
        y =  target_pop - ((target_pop / 100) * 2.5),
        aes(label = "Target Population",
            hjust = 'left'),
        size = 4,
        colour = 'blue'
      ) +
      scale_alpha_continuous(guide = 'none') +
      scale_y_continuous(
        expand = c(0, 0),
        labels = comma,
        limits = c(0, max(
          c(target_pop),
          max(new_pts_v_dummy$pop_cap_tot)
        ))
      ) +
      scale_x_continuous(
        expand = c(0, 0),
        labels = label_number(accuracy = 1),
        limits = c(0, (j + 1))#,
        #breaks = round(seq(0, j)),
        #1
      ) +
      labs(x = "New Agro-Dealers (#)", y = "Population within 1 Hour (#)") +
      theme(
        #panel.grid.major.x = element_blank(),
        #panel.grid.minor.x = element_blank(),
        #axis.title.x = element_blank(),
        axis.title.x = element_text(colour = 'grey20'),
        axis.title.y = element_text(colour = 'grey20'),
        axis.text.y = element_text(angle = 45),
        panel.background = element_rect(fill = 'white', color = NA),
        panel.grid.major.y = element_line(color = 'grey', linetype = 'dotted')
      )
    
    # ----combine map and bar chart ----
    
    
    access_covered <-
      plot_grid(
        access_g_add_1hr_pot_v_plot,
        covered_population_plot,
        align = "h",
        axis = "bt",
        rel_widths = c(1.3, 1)
      )
    
    
    # ----save combined plots as png ----
    ggsave(
      file = paste0("charts/access_g_add_1hr_pot_v_plot_", j, ".png"),
      plot = access_covered,
      width = 10,
      height = 5,
      units = "in",
      dpi = 300
    )
    
    # files uploaded to https://ezgif.com/ for animated gif
    
  }
  
  cat("Completed after ", j, "iterations\n\n")
  
  # ----CLEAN UP----
  # re-initialise values
  
  potential_pop_v <- 0
  r_remaining_pop_v <- pop_mwi_utm_rsmp - r_cnfa_pop_v
  
}


```


## Bicycle accessibility analysis with existing agro-dealers

### Total Time

```{r bicycle_access_existing, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Bicycle Accessibility - Existing Agro-Dealers", dev = 'png', results='markup'}


tr_b <- transition(friction_b,function(x) 1/mean(x), 8) # transition from bicycle friction
tr_b <- geoCorrection(tr_b, scl = TRUE) # Geographic correction is necessary for all objects of the class Transition that are made with directions > 4.The function will correct for diagonal connections between grid cells (which cover a longer distance than vertical or horizontal connections).


cnfa_ag_dealers_sp <- as_Spatial(cnfa_ag_dealers_sdf)

cnfa_cost_b <- accCost(tr_b, cnfa_ag_dealers_sp)

gplot(cnfa_cost_b, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
    geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_sf(data = cnfa_ag_dealers_sdf, colour = 'dark green', size = 0.5, shape = 3,
      inherit.aes = FALSE) +
  scale_fill_gradient(low = 'yellow',
                        high = 'red', 
                        na.value = NA, limits = c(0,10000)) +
  
  xlim(450000, 725000) +
  ylim(8300000, 8650000) +
  labs(fill = "-------------\nTime to\nNGO\nAgro-\nDealers\nBicycles\n-------------") +
  
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

```
### Within 1 hour

```{r bicycle_access_existing_1hr, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Within 1 hour - Bicycle Accessibility - Existing Agro-Dealers", dev = 'png', results='markup'}

r_cnfa_1hr_b <-  reclassify(cnfa_cost_b, matrix(c(-Inf, 3600, 1, 3600, Inf, 0),
                                    ncol = 3,
                                    byrow = TRUE))

gplot(r_cnfa_1hr_b, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
    geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_sf(data = cnfa_ag_dealers_sdf, colour = 'dark green', size = 0.5, shape = 3,
      inherit.aes = FALSE) +
  scale_fill_gradient(low = 'yellow',
                        high = 'red', 
                        na.value = NA, limits = c(1,1)) +
  
  xlim(450000, 725000) +
  ylim(8300000, 8650000) +
  labs(fill = "-------------\nWithin\n1 hour of\nNGO\nAgro-\nDealers by\nBicycles\n-------------") +
  
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

r_cnfa_pop_b <- r_cnfa_1hr_b * pop_mwi_utm_rsmp
cnfa_pop_b <- cellStats(r_cnfa_pop_b, stat='sum')
cat("Total Population within 1 hour of Existing Agro-Dealers by Bicycles = ", cnfa_pop_b,"\n\n")

if (cnfa_pop_b < target_pop) {
  run_heuristic_b <- TRUE
  cat("Target Population not reached. Run the heuristic for potential agro-dealers")
  
} else {
  run_heuristic_b <- FALSE
  cat("Target Population reached. Do not run the heuristic for potential agro-dealers")
}

```

## Bicycle greedy add heuristic with potential agro-dealers

If the target population is not reached by the existing Existing agro-dealers then I need to consider the other potential agro-dealers.

Before running the greedy add heuristic I need to check whether it is possible to reach 80% of the population from the other potential agro-dealer locations.


### Remaining Population

```{r bicycle_remaining_population, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Bicycle Accessibility - Remaining Population", dev = 'png', results='markup'}

if ( run_heuristic_b == TRUE) {
 

  r_covered_pop_b <- r_cnfa_pop_b
  
  # remove the already covered population from the population grid to give remaining value
  r_remaining_pop_b <- pop_mwi_utm_rsmp - r_cnfa_pop_b
  
  # reclassify to show the area already covered as NA 
  r_remaining_pop_b_rcl  <-
    reclassify(r_remaining_pop_b, matrix(c(0, NA),
                                         ncol = 2,
                                         byrow = TRUE))
  
  r_remaining_pop_b_df <- gplot_data(r_remaining_pop_b_rcl)  # convert to geom_tile type of raster

remaining_pop_b_plot <- gplot(r_remaining_pop_b, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
    geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_sf(
    data = cnfa_ag_dealers_sdf,
    colour = 'dark green',
    size = 0.5,
    shape = 3,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = pot_ag_dealers_sdf,
    colour = 'blue',
    size = 0.5,
    shape = 1,
    inherit.aes = FALSE
  ) +
  scale_fill_gradient(
    low = 'yellow',
    high = 'red',
    na.value = NA,
    limits = c(0.5, 5000)
  ) +
  
  xlim(450000, 725000) +
  ylim(8300000, 8650000) +
  labs(fill = "-------------\nRemaining\nPopulation\nBicycles\n-------------") +
  
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

print(remaining_pop_b_plot)

diff_pop_b <- cellStats(r_remaining_pop_b,stat='sum')
cat("Target Population = ", formatC(target_pop, format="d", big.mark=","),"\n\n")
cat("Total Population within 1 Hour = ", formatC(cnfa_pop_b, format="d", big.mark=","),"\n\n")
cat("Total Uncovered Population = ", formatC(diff_pop_b, format="d", big.mark=","),"\n\n")
cat("Remaining Population to Target = ", formatC((target_pop - cnfa_pop_b), format="d", big.mark=","),"\n\n")

potential_pop_b <- 0

}

```

```{r pop_rem_b_2_postgres, cache=TRUE, results='hide'}

if ( run_heuristic_b == TRUE) {
  
# this writes the  remaining pop surface to postgres

temp_points <- st_as_sf(rasterToPoints(r_remaining_pop_b, function(x){x>0}, spatial=TRUE))
temp_points$Id <- seq.int(nrow(temp_points))

st_write(obj = temp_points, dsn = con, Id(schema="coverage", table = "remaining_pop_b_points"))

}
```

### Total Time

```{r bicycle_access_potential, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Bicycle Accessibility - Potential Agro-Dealers", dev = 'png', results='hide'}

if ( run_heuristic_b == TRUE) {
  
pot_ag_dealers_sp <- as_Spatial(pot_ag_dealers_sdf)

pot_cost_b <- accCost(tr_b, pot_ag_dealers_sp)

access_pot_b_plot <- gplot(pot_cost_b, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
      geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_sf(
    data = pot_ag_dealers_sdf,
    ,
    colour = 'blue',
    size = 0.5,
    shape = 1,
    inherit.aes = FALSE
  ) +
  scale_fill_gradient(low = 'yellow',
                        high = 'red', 
                        na.value = NA, limits = c(0,10000)) +
  
  xlim(450000, 725000) +
  ylim(8300000, 8650000) +
  labs(fill = "-------------\nTime to\nnon-NGO\nPotential\nAgro-\nDealers\nBicycles\n-------------") +
  
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

print(access_pot_b_plot)

}

```

### Within 1 hour

```{r bicycle_access_potential_1hr, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Within 1 hour - Bicycle Accessibility - Potential Agro-Dealers", dev = 'png', results='markup'}

if (run_heuristic_b == TRUE) {
  r_pot_1hr_b <-
    reclassify(pot_cost_b, matrix(c(-Inf, 3600, 1, 3600, Inf, 0),
                                  ncol = 3,
                                  byrow = TRUE))
  
  access_1hr_pot_b_plot <-   gplot(r_pot_1hr_b, maxpixels = 50000) +
    geom_tile(aes(fill = value), alpha = 1) +
        geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
    geom_sf(
      data = pot_ag_dealers_sdf,
      colour = 'blue',
      size = 0.5,
      shape = 1,
      inherit.aes = FALSE
    ) +
    scale_fill_gradient(
      low = 'yellow',
      high = 'red',
      na.value = NA,
      limits = c(1, 1)
    ) +
    
    xlim(450000, 725000) +
    ylim(8300000, 8650000) +
    labs(fill = "-------------\nWithin\n1 hour of\nnon-NGO\nPotential\nAgro-\nDealers by\nBicycles\n-------------") +
    
    theme(
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank()
    )
  
  print(access_1hr_pot_b_plot)
  r_pot_pop_b <- r_pot_1hr_b * r_remaining_pop_b
  pot_pop_b <- cellStats(r_pot_pop_b, stat = 'sum')
  cat(
    "Total Population within 1 hour of New Agro-Dealers by Bicycles (excluding population already covered by Existing Agro-Dealers) = ",
    pot_pop_b, "\n\n"
  )
  cnfa_pot_pop_b <- (cnfa_pop_b +  pot_pop_b)
  cat(
    "Total Population within 1 hour of both Existing and New Agro-Dealers by Bicycles = ",
    cnfa_pot_pop_b, "\n\n"
  )
    cat(
    "Target Population within 1 hour of both Existing and New Agro-Dealers by Bicycles = ",
    target_pop, "\n\n"
  )
  
  if (cnfa_pot_pop_b < target_pop) {
    run_heuristic_b <- FALSE
    cat(
      "Target Population still not reached. Do not run the heuristic for potential agro-dealers"
    )
    
  } else {
    run_heuristic_b <- TRUE
    cat("Target Population can be reached. Run the heuristic for potential agro-dealers")
  }
}

```

### Heuristic

```{r bicycle_g_add_potential, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Bicycle Accessibility - Potential Agro-Dealers", dev = 'png', results='markup'}


if (run_heuristic_b == TRUE) {
  # ----CREATE A TEMP DATAFRAME OF POINTS WITH ID GEOMETRY AND (EMPTY) pop1hr FIELD----
  
  temp_pot <- dplyr::select(pot_ag_dealers_sdf, id)
  temp_pot$pop1hr_b <- 0
  temp_pot_sp_b <-
    as_Spatial(temp_pot) # convert to sp for AccCost function
  
  # -----create a vector to store id of maxpop points-----
  
  highpop_pt_b <- c()
  
  # ----create an empty data frame of optimum points with attributes
  
  highpop_df_b <-
    data.frame(
      'id' = integer(),
      'pop_cap_j' = integer(),
      'iteration' = integer(),
      'pop_cap_tot' = integer()
    )
  
  
  # ----start loops----
  
  j = 0 # counter for number of iterations
  
  # ----PLOT START MAP AND CHARTS ----
  # ----plot the start map----
  
  access_g_add_1hr_pot_b_plot <- ggplot() +
    geom_sf(
      data = boundary_mcr_utm,
      fill = 'grey',
      col = NA,
      na.rm = TRUE,
      inherit.aes = FALSE
    ) +
    geom_tile(data = pop_mwi_utm_rsmp_df,
              aes(x = x, y = y, fill = value)) +
    geom_tile(
      data = dplyr::filter(r_remaining_pop_b_df, !is.na(value)),
      aes(x = x, y = y),
      fill = "grey20",
      alpha = 0.5
    )   +
    geom_tile(
      data = dplyr::filter(lc_c_mwi_rcl_water_df, !is.na(value)),
      aes(x = x, y = y),
      fill = "blue",
      alpha = 0.5
    )   +
    geom_sf(
      data = central_mask,
      fill = NA,
      col = 'dark grey',
      na.rm = TRUE,
      inherit.aes = FALSE
    ) +
    geom_sf(
      data = boundary_mcr_utm,
      fill = NA,
      colour = 'grey20',
      size = 1.5,
      inherit.aes = FALSE
    ) +
    geom_sf(
      data = boundary_mcr_dist_utm,
      fill = NA,
      colour = 'grey20',
      size = 0.75,
      inherit.aes = FALSE
    )    +
    geom_sf(
      data = cnfa_ag_dealers_sdf,
      colour = 'dark green',
      size = 1,
      aes(shape = "Existing"),
      inherit.aes = FALSE
    ) +
    geom_text(
      x = 660000,
      y = 8320000 ,
      aes(
        label = paste0(
          "Population within 1 Hour: ",
          formatC((cnfa_pop_b),
                  format = "d",
                  big.mark = ",")
        ),
        hjust = 'right'
      ),
      size = 4,
      colour = 'dark green'
    ) +
    geom_text(
      x = 660000,
      y = 8340000 ,
      aes(
        label = paste0("Target Population: ", formatC((target_pop),
                                                      format = "d",
                                                      big.mark = ","
        )),
        hjust = 'right'
      ),
      size = 4,
      colour = 'blue'
    ) +
    geom_text(
      x = 660000,
      y = 8360000 ,
      aes(label = paste0(j,  " New Agro-Dealers"),
          hjust = 'right'),
      size = 4,
      colour = 'black'
    ) +
    scale_shape_manual(name = "Agro-Dealers", values = c("Existing" = 3)) +
    #scale_colour_manual(name = "", values = c("Existing" = "dark green", "New" = "blue")) +
    scale_fill_gradient(
      labels = comma,
      low = 'yellow',
      high = 'red',
      na.value = NA,
      limits = c(0.5, 10000)
    ) +
    scale_x_continuous(expand = c(0, 0),
                       limits = c(455000, 720000)) +
    scale_y_continuous(expand = c(0, 0),
                       limits = c(8305000, 8655000)) +
    labs(fill = expression(
      paste(
        "-------------\nPopulation\nWithin\n1 Hour\n-------------\npersons/km" ^
          2
      )
    )) +
    theme(
      #panel.background = element_rect(fill = 'white'),
      #panel.grid.major.x = element_blank(),
      #panel.grid.major.x = element_line(colour = 'grey'),
      #panel.grid.minor.x = element_blank(),
      panel.grid.minor.x = element_line(colour = 'grey'),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      panel.background = element_rect(fill = 'white', color = NA),
      panel.grid.major = element_line(color = 'grey', linetype = 'dotted'),
      panel.grid.minor = element_line(color = 'green', size = 2),
      legend.key = element_rect(fill = 'white')
    ) +
    guides(fill = guide_colourbar(order = 1),
           shape = guide_legend(order = 2))
  
  ## ----add a dummy point for plotting bar graph----
  crs <- st_crs(32736)
  dummy_point <- st_sf(
    id = -1,
    pop1hr_b = 0,
    pop_cap_j = 0,
    iteration = 0,
    pop_cap_tot = cnfa_pop_b,
    geometry = st_sfc(st_point(0:1)),
    crs = crs
  )
  
  ## ----plot the start bar chart----
  
  covered_population_plot <- ggplot(dummy_point) +
    geom_bar(aes(
      x = iteration,
      y = pop_cap_tot,
      alpha = (iteration / j)
    ),
    stat = 'identity',
    fill = 'dark green') +
    geom_point(aes(iteration, pop_cap_tot)) +
    geom_hline(
      yintercept = (target_pop),
      linetype = 'dashed',
      color = 'blue'
    ) +
    geom_text(
      x = 0,
      y =  target_pop - ((target_pop / 100) * 2.5),
      aes(label = "Target Population",
          hjust = 'left'),
      size = 4,
      colour = 'blue'
    ) +
    scale_alpha_continuous(guide = 'none') +
    scale_y_continuous(expand = c(0, 0),
                       labels = comma,
                       limits = c(0, max(
                         c(target_pop),
                         max(dummy_point$pop_cap_tot)
                       ))) +
    scale_x_continuous(
      expand = c(0, 0),
      labels = label_number(accuracy = 1),
      limits = c(0, (j + 1))#,
      #breaks = round(seq(0, j)),
      #1
    ) +
    labs(x = "New Agro-Dealers (#)", y = "Population within 1 Hour (#)") +
    theme(
      #panel.grid.major.x = element_blank(),
      #panel.grid.minor.x = element_blank(),
      #axis.title.x = element_blank(),
      axis.title.x = element_text(colour = 'grey20'),
      axis.title.y = element_text(colour = 'grey20'),
      axis.text.y = element_text(angle = 45),
      panel.background = element_rect(fill = 'white', color = NA),
      panel.grid.major.y = element_line(color = 'grey', linetype = 'dotted')
    )
  
  # ----combine map and bar chart ----
  
  
  access_covered <-
    plot_grid(
      access_g_add_1hr_pot_b_plot,
      covered_population_plot,
      align = "h",
      axis = "bt",
      rel_widths = c(1.3, 1)
    )
  
  
  # ----save combined plots as png ----
  ggsave(
    file = paste0("charts/access_g_add_1hr_pot_b_plot_", j, ".png"),
    plot = access_covered,
    width = 10,
    height = 5,
    units = "in",
    dpi = 300
  )
  
  # files uploaded to https://ezgif.com/ for animated gif
  
  # ----while target population not covered----
  
  while ((cnfa_pop_b + potential_pop_b) < target_pop) {
    j = j + 1
    
    
    # ----for every point in the temporary sp data frame----
    
    
    for (i in 1:length(temp_pot_sp_b)) {
      #print(j) # for debugging purposes
      
      # ----RUN COSTDISTANCE USING FRICTION GRID AND NEW TARGET POINT----
      acc_i_b <-
        accCost(tr_b, temp_pot_sp_b[i, ]) %>%
        reclassify(matrix(c(-Inf, 3600, 1, 3600, Inf, 0)))
      
      # ----multiply hour cost grid with remaining population get sum and add value to temporary sp data frame pop1hr_b field ----
      
      popsum_i_b <- (acc_i_b * r_remaining_pop_b)  %>%
        cellStats(stat = 'sum')
      
      temp_pot_sp_b[i, 2] <- popsum_i_b
      
    }
    
    # ----finish for loop----
    
    
    # ----COMPARE total_pop AND RECORD POINT-ID----
    
    # the index of the point with the maximum population covered
    highpop_index_b <- which.max(temp_pot_sp_b$pop1hr_b)
    print(paste(
      "Index of the point with the maximum population covered is : ",
      which.max(temp_pot_sp_b$pop1hr_b)
    ))
    
    # the id of the point with the maximum population covered using the index
    highpop_id_b <- temp_pot_sp_b$id[[highpop_index_b]]
    print(paste(
      "Id of the point with the maximum population covered is : ",
      highpop_id_b
    ))
    
    # the maximum population covered using the index
    print(paste(
      "Maximum population covered is : ",
      max(temp_pot_sp_b$pop1hr_b)
    ))
    
    # ----save the point with the maximum population covered in vector----
    
    highpop_pt_b <- append(highpop_pt_b, highpop_id_b)
    
    
    # ----RERUN THE COSTDISTANCE FOR THE OPTIMUM POINT , SAVE AND DISCARD----
    
    # using saved index
    
    acc_high_b <- accCost(tr_b, temp_pot_sp_b[highpop_index_b,]) %>%
      reclassify(matrix(c(-Inf, 3600, 1, 3600, Inf, 0)))
    
    # ----multiply hour cost grid with remaining population get sum ----
    
    popsum_high_b <- (acc_high_b * r_remaining_pop_b)
    potential_pop_i_b <- cellStats(popsum_high_b, stat = 'sum')
    cat(
      "Total Population within 1 hour of number",
      j ,
      " New Potential Agro-Dealer = ",
      potential_pop_i_b,
      "\n\n"
    )
    cat(
      "Total Population within 1 hour of all Existing and ",
      j ,
      " New Potential Agro-Dealers = ",
      (cnfa_pop_b + potential_pop_b + potential_pop_i_b),
      "\n\n"
    )
    
    # ----update population sums----
    
    # update covered population
    potential_pop_b <- potential_pop_i_b + potential_pop_b
    
    # update remaining population rasters
    r_remaining_pop_b <- r_remaining_pop_b - popsum_high_b
    
    # reclassify to show the area already covered as NA
    r_remaining_pop_b_rcl  <-
      reclassify(r_remaining_pop_b, matrix(c(0, NA),
                                           ncol = 2,
                                           byrow = TRUE))
    
    r_remaining_pop_b_df <-
      gplot_data(r_remaining_pop_b_rcl)  # convert to geom_tile type of raster
    
    
    # update remaining population
    diff_pop_b <- cellStats(r_remaining_pop_b, stat = 'sum')
    cat("Total Remaining Possible Population = ", diff_pop_b, "\n\n")
    cat(
      "Remaining Target Population = ",
      (target_pop - cnfa_pop_b - potential_pop_b),
      "\n\n"
    )
    
    # ----create a data frame of the newest optimum point with attributes and inner-join to temporary points for mapping
    
    newest_highpop_df_b <-
        data.frame(
          'id' = as.integer(highpop_id_b),
          'pop_cap_j' = as.integer(potential_pop_i_b),
          'iteration' = as.integer(j),
          'pop_cap_tot' = as.integer(cnfa_pop_b + potential_pop_b)
        )
      
    
    newest_pts_b <- inner_join(temp_pot, newest_highpop_df_b, by = 'id')
    
    # ----remove latest optimum point from temp_pot_sp_b to reduce burden
    
    temp_pot_sp_b <- temp_pot_sp_b[-c(highpop_index_b), ]
    
    # ----PRODUCE MAP OF CAPTURED POPULATION AND BARCHART OF THIS ITERATION OF WHILE LOOP----
    
    newest_pts_b_dummy <- rbind(dummy_point, newest_pts_b)
    
    
    # for the first iteration use a slightly different code for mapping:
    
    if (j == 1) {
      
      # ----plot the map iteration 1----
      cat("j should be 1 and is: ", j)
      
      access_g_add_1hr_pot_b_plot <- ggplot() +
        geom_sf(
          data = boundary_mcr_utm,
          fill = 'grey',
          col = NA,
          na.rm = TRUE,
          inherit.aes = FALSE
        ) +
        geom_tile(data = pop_mwi_utm_rsmp_df,
                  aes(x = x, y = y, fill = value)) +
        geom_tile(
          data = dplyr::filter(r_remaining_pop_b_df, !is.na(value)),
          aes(x = x, y = y),
          fill = "grey20",
          alpha = 0.5
        )   +
        geom_tile(
          data = dplyr::filter(lc_c_mwi_rcl_water_df, !is.na(value)),
          aes(x = x, y = y),
          fill = "blue",
          alpha = 0.5
        )   +
        geom_sf(
          data = central_mask,
          fill = NA,
          col = 'dark grey',
          na.rm = TRUE,
          inherit.aes = FALSE
        ) +
        geom_sf(
          data = boundary_mcr_utm,
          fill = NA,
          colour = 'grey20',
          size = 1.5,
          inherit.aes = FALSE
        ) +
        geom_sf(
          data = boundary_mcr_dist_utm,
          fill = NA,
          colour = 'grey20',
          size = 0.75,
          inherit.aes = FALSE
        )    +
        geom_sf(
          data = cnfa_ag_dealers_sdf,
          colour = 'dark green',
          #size = 1,
          #aes(shape = "Existing", size = "Existing"),
          aes(shape = "Existing", size = "Existing"),
          inherit.aes = FALSE
        ) +
        #geom_sf(
        #  data = new_pts_b[-c(j),],
        #  colour = 'dark green',
          #size = 1,
          #aes(shape = "New", size = "New"),
        #  aes(shape = "New", size = "New"),
        #  inherit.aes = FALSE
        #) +
        geom_sf(
          data = newest_pts_b,
          colour = 'dark green',
          fill = 'dark green',
          #size = 3,
          #shape = 21,
          #aes(shape = "Newest", size = "Newest"),
          aes(shape = "Newest", size = "Newest"),
          inherit.aes = FALSE
        ) +
        #geom_sf(
        #  data = new_pts_b,
        #  colour = 'dark green',
        #  size = 1,
        #  aes(shape = "New"),
        #  inherit.aes = FALSE
        #) +
        geom_text(
          x = 660000,
          y = 8320000 ,
          aes(
            label = paste0(
              "Population within 1 Hour: ",
              formatC((potential_pop_b + cnfa_pop_b),
                      format = "d",
                      big.mark = ","
              )
            ),
            hjust = 'right'
          ),
          size = 4,
          colour = 'dark green'
        ) +
        geom_text(
          x = 660000,
          y = 8340000 ,
          aes(
            label = paste0("Target Population: ", formatC((target_pop),
                                                          format = "d",
                                                          big.mark = ","
            )),
            hjust = 'right'
          ),
          size = 4,
          colour = 'blue'
        ) +
        geom_text(
          x = 660000,
          y = 8360000 ,
          aes(label = paste0(j, " New Agro-Dealers"),
              hjust = 'right'),
          size = 4,
          colour = 'black'
        ) +
        scale_shape_manual(name = "Agro-Dealers",
                           values = c(
                             "Existing" = 3,
                             "Newest" = 21
                           )) +
        scale_size_manual(name = "Agro-Dealers",
                          values = c(
                            "Existing" = 1,
                            "Newest" = 3
                          )) +
        scale_fill_gradient(
          labels = comma,
          low = 'yellow',
          high = 'red',
          na.value = NA,
          limits = c(0.5, 10000)
        ) +
        scale_x_continuous(expand = c(0, 0),
                           limits = c(455000, 720000)) +
        scale_y_continuous(expand = c(0, 0),
                           limits = c(8305000, 8655000)) +
        labs(fill = expression(
          paste(
            "-------------\nPopulation\nWithin\n1 Hour\n-------------\npersons/km" ^
              2
          )
        )) +
        theme(
          #panel.background = element_rect(fill = 'white'),
          #panel.grid.major.x = element_blank(),
          #panel.grid.major.x = element_line(colour = 'grey'),
          #panel.grid.minor.x = element_blank(),
          panel.grid.minor.x = element_line(colour = 'grey'),
          axis.title.x = element_blank(),
          axis.title.y = element_blank(),
          panel.background = element_rect(fill = 'white', color = NA),
          panel.grid.major = element_line(color = 'grey', linetype = 'dotted'),
          panel.grid.minor = element_line(color = 'green', size = 2),
          legend.key = element_rect(fill = 'white')
        ) +
        guides(
          fill = guide_colourbar(order = 1),
          shape = guide_legend(order = 2),
          size = guide_legend(order = 2)
        )
      
          ## ----plot the bar chart in iteration 1----
    
    covered_population_plot <- ggplot(newest_pts_b_dummy) +
      geom_bar(aes(
        x = iteration,
        y = pop_cap_tot,
        alpha = (iteration / j)
      ),
      stat = 'identity',
      fill = 'dark green',) +
      geom_point(aes(iteration, pop_cap_tot)) +
      geom_hline(
        yintercept = (target_pop),
        linetype = 'dashed',
        color = 'blue'
      ) +
      geom_text(
        x = 0,
        y =  target_pop - ((target_pop / 100) * 2.5),
        aes(label = "Target Population",
            hjust = 'left'),
        size = 4,
        colour = 'blue'
      ) +
      scale_alpha_continuous(guide = 'none') +
      scale_y_continuous(
        expand = c(0, 0),
        labels = comma,
        limits = c(0, max(
          c(target_pop),
          max(newest_pts_b_dummy$pop_cap_tot)
        ))
      ) +
      scale_x_continuous(
        expand = c(0, 0),
        labels = label_number(accuracy = 1),
        limits = c(0, (j + 1))#,
        #breaks = round(seq(0, j)),
        #1
      ) +
      labs(x = "New Agro-Dealers (#)", y = "Population within 1 Hour (#)") +
      theme(
        #panel.grid.major.x = element_blank(),
        #panel.grid.minor.x = element_blank(),
        #axis.title.x = element_blank(),
        axis.title.x = element_text(colour = 'grey20'),
        axis.title.y = element_text(colour = 'grey20'),
        axis.text.y = element_text(angle = 45),
        panel.background = element_rect(fill = 'white', color = NA),
        panel.grid.major.y = element_line(color = 'grey', linetype = 'dotted')
      )
      
      
    } else {
      # ----plot the map iteration > 1----
      cat("j should not be 1 and is: ", j)
      
      access_g_add_1hr_pot_b_plot <- ggplot() +
        geom_sf(
          data = boundary_mcr_utm,
          fill = 'grey',
          col = NA,
          na.rm = TRUE,
          inherit.aes = FALSE
        ) +
        geom_tile(data = pop_mwi_utm_rsmp_df,
                  aes(x = x, y = y, fill = value)) +
        geom_tile(
          data = dplyr::filter(r_remaining_pop_b_df, !is.na(value)),
          aes(x = x, y = y),
          fill = "grey20",
          alpha = 0.5
        )   +
        geom_tile(
          data = dplyr::filter(lc_c_mwi_rcl_water_df, !is.na(value)),
          aes(x = x, y = y),
          fill = "blue",
          alpha = 0.5
        )   +
        geom_sf(
          data = central_mask,
          fill = NA,
          col = 'dark grey',
          na.rm = TRUE,
          inherit.aes = FALSE
        ) +
        geom_sf(
          data = boundary_mcr_utm,
          fill = NA,
          colour = 'grey20',
          size = 1.5,
          inherit.aes = FALSE
        ) +
        geom_sf(
          data = boundary_mcr_dist_utm,
          fill = NA,
          colour = 'grey20',
          size = 0.75,
          inherit.aes = FALSE
        )    +
        geom_sf(
          data = cnfa_ag_dealers_sdf,
          colour = 'dark green',
          #size = 1,
          #aes(shape = "Existing", size = "Existing"),
          aes(shape = "Existing", size = "Existing"),
          inherit.aes = FALSE
        ) +
        geom_sf(
          data = new_pts_b,
          colour = 'dark green',
          #size = 1,
          #aes(shape = "New", size = "New"),
          aes(shape = "New", size = "New"),
          inherit.aes = FALSE
        ) +
        geom_sf(
          data = newest_pts_b,
          colour = 'dark green',
          fill = 'dark green',
          #size = 3,
          #shape = 21,
          #aes(shape = "Newest", size = "Newest"),
          aes(shape = "Newest", size = "Newest"),
          inherit.aes = FALSE
        ) +
        #geom_sf(
        #  data = new_pts_b,
        #  colour = 'dark green',
        #  size = 1,
        #  aes(shape = "New"),
        #  inherit.aes = FALSE
        #) +
        geom_text(
          x = 660000,
          y = 8320000 ,
          aes(
            label = paste0(
              "Population within 1 Hour: ",
              formatC((potential_pop_b + cnfa_pop_b),
                      format = "d",
                      big.mark = ","
              )
            ),
            hjust = 'right'
          ),
          size = 4,
          colour = 'dark green'
        ) +
        geom_text(
          x = 660000,
          y = 8340000 ,
          aes(
            label = paste0("Target Population: ", formatC((target_pop),
                                                          format = "d",
                                                          big.mark = ","
            )),
            hjust = 'right'
          ),
          size = 4,
          colour = 'blue'
        ) +
        geom_text(
          x = 660000,
          y = 8360000 ,
          aes(label = paste0(j, " New Agro-Dealers"),
              hjust = 'right'),
          size = 4,
          colour = 'black'
        ) +
        scale_shape_manual(name = "Agro-Dealers",
                           values = c(
                             "Existing" = 3,
                             "New" = 1,
                             "Newest" = 21
                           )) +
        scale_size_manual(name = "Agro-Dealers",
                          values = c(
                            "Existing" = 1,
                            "New" = 1,
                            "Newest" = 3
                          )) +
        scale_fill_gradient(
          labels = comma,
          low = 'yellow',
          high = 'red',
          na.value = NA,
          limits = c(0.5, 10000)
        ) +
        scale_x_continuous(expand = c(0, 0),
                           limits = c(455000, 720000)) +
        scale_y_continuous(expand = c(0, 0),
                           limits = c(8305000, 8655000)) +
        labs(fill = expression(
          paste(
            "-------------\nPopulation\nWithin\n1 Hour\n-------------\npersons/km" ^
              2
          )
        )) +
        theme(
          #panel.background = element_rect(fill = 'white'),
          #panel.grid.major.x = element_blank(),
          #panel.grid.major.x = element_line(colour = 'grey'),
          #panel.grid.minor.x = element_blank(),
          panel.grid.minor.x = element_line(colour = 'grey'),
          axis.title.x = element_blank(),
          axis.title.y = element_blank(),
          panel.background = element_rect(fill = 'white', color = NA),
          panel.grid.major = element_line(color = 'grey', linetype = 'dotted'),
          panel.grid.minor = element_line(color = 'green', size = 2),
          legend.key = element_rect(fill = 'white')
        ) +
        guides(
          fill = guide_colourbar(order = 1),
          shape = guide_legend(order = 2),
          size = guide_legend(order = 2)
        )
      
               ## ----plot the bar chart in iteration > 1----
    
    covered_population_plot <- ggplot(new_pts_b_dummy) +
      geom_bar(aes(
        x = iteration,
        y = pop_cap_tot,
        alpha = (iteration / j)
      ),
      stat = 'identity',
      fill = 'dark green',) +
      geom_point(aes(iteration, pop_cap_tot)) +
      geom_hline(
        yintercept = (target_pop),
        linetype = 'dashed',
        color = 'blue'
      ) +
      geom_text(
        x = 0,
        y =  target_pop - ((target_pop / 100) * 2.5),
        aes(label = "Target Population",
            hjust = 'left'),
        size = 4,
        colour = 'blue'
      ) +
      scale_alpha_continuous(guide = 'none') +
      scale_y_continuous(
        expand = c(0, 0),
        labels = comma,
        limits = c(0, max(
          c(target_pop),
          max(new_pts_b_dummy$pop_cap_tot)
        ))
      ) +
      scale_x_continuous(
        expand = c(0, 0),
        labels = label_number(accuracy = 1),
        limits = c(0, (j + 1))#,
        #breaks = round(seq(0, j)),
        #1
      ) +
      labs(x = "New Agro-Dealers (#)", y = "Population within 1 Hour (#)") +
      theme(
        #panel.grid.major.x = element_blank(),
        #panel.grid.minor.x = element_blank(),
        #axis.title.x = element_blank(),
        axis.title.x = element_text(colour = 'grey20'),
        axis.title.y = element_text(colour = 'grey20'),
        axis.text.y = element_text(angle = 45),
        panel.background = element_rect(fill = 'white', color = NA),
        panel.grid.major.y = element_line(color = 'grey', linetype = 'dotted')
      )
      
      }
    

    
    # ----combine map and bar chart ----
    
    
    access_covered <-
      plot_grid(
        access_g_add_1hr_pot_b_plot,
        covered_population_plot,
        align = "h",
        axis = "bt",
        rel_widths = c(1.3, 1)
      )
    
    
    # ----save combined plots as png ----
    ggsave(
      file = paste0("charts/access_g_add_1hr_pot_b_plot_", j, ".png"),
      plot = access_covered,
      width = 10,
      height = 5,
      units = "in",
      dpi = 300
    )
    
    # files uploaded to https://ezgif.com/ for animated gif
    
    
        # ----create a data frame of optimum points with attributes and inner-join to temporary points for mapping in the next iteration
    
    highpop_df_b <-
      rbind(
        highpop_df_b,
        data.frame(
          'id' = as.integer(highpop_id_b),
          'pop_cap_j' = as.integer(potential_pop_i_b),
          'iteration' = as.integer(j),
          'pop_cap_tot' = as.integer(cnfa_pop_b + potential_pop_b)
        )
      )
    
    new_pts_b <- inner_join(temp_pot, highpop_df_b, by = 'id')
    new_pts_b_dummy <- rbind(dummy_point, new_pts_b)
    
  }
  
  cat("Completed after ", j, "iterations\n\n")
  
  # ----CLEAN UP----
  # re-initialise values
  
  potential_pop_b <- 0
  r_remaining_pop_b <- pop_mwi_utm_rsmp - r_cnfa_pop_b
  
}


```


## Walking accessibility analysis with existing agro-dealers

### Total Time

```{r walking_access_existing, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Walking Accessibility - Existing Agro-Dealers", dev = 'png', results='markup'}


tr_w <- transition(friction_w,function(x) 1/mean(x), 8) # transition from walking friction
tr_w <- geoCorrection(tr_w, scl = TRUE) # Geographic correction is necessary for all objects of the class Transition that are made with directions > 4.The function will correct for diagonal connections between grid cells (which cover a longer distance than vertical or horizontal connections).


cnfa_ag_dealers_sp <- as_Spatial(cnfa_ag_dealers_sdf)

cnfa_cost_w <- accCost(tr_w, cnfa_ag_dealers_sp)

gplot(cnfa_cost_w, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
    geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_sf(data = cnfa_ag_dealers_sdf, colour = 'dark green', size = 0.5, shape = 3,
      inherit.aes = FALSE) +
  scale_fill_gradient(low = 'yellow',
                        high = 'red', 
                        na.value = NA, limits = c(0,10000)) +
  
  xlim(450000, 725000) +
  ylim(8300000, 8650000) +
  labs(fill = "-------------\nTime to\nNGO\nAgro-\nDealers\nWalking\n-------------") +
  
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

```
### Within 1 hour

```{r walking_access_existing_1hr, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Within 1 hour - Walking Accessibility - Existing Agro-Dealers", dev = 'png', results='markup'}

r_cnfa_1hr_w <-  reclassify(cnfa_cost_w, matrix(c(-Inf, 3600, 1, 3600, Inf, 0),
                                    ncol = 3,
                                    byrow = TRUE))

gplot(r_cnfa_1hr_w, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
    geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_sf(data = cnfa_ag_dealers_sdf, colour = 'dark green', size = 0.5, shape = 3,
      inherit.aes = FALSE) +
  scale_fill_gradient(low = 'yellow',
                        high = 'red', 
                        na.value = NA, limits = c(1,1)) +
  
  xlim(450000, 725000) +
  ylim(8300000, 8650000) +
  labs(fill = "-------------\nWithin\n1 hour of\nNGO\nAgro-\nDealers by\nWalking\n-------------") +
  
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

r_cnfa_pop_w <- r_cnfa_1hr_w * pop_mwi_utm_rsmp
cnfa_pop_w <- cellStats(r_cnfa_pop_w, stat='sum')
cat("Total Population within 1 hour of Existing Agro-Dealers by Walking = ", cnfa_pop_w,"\n\n")

if (cnfa_pop_w < target_pop) {
  run_heuristic_w <- TRUE
  cat("Target Population not reached. Run the heuristic for potential agro-dealers")
  
} else {
  run_heuristic_w <- FALSE
  cat("Target Population reached. Do not run the heuristic for potential agro-dealers")
}

```

## Walking greedy add heuristic with potential agro-dealers

If the target population is not reached by the existing Existing agro-dealers then I need to consider the other potential agro-dealers.

Before running the greedy add heuristic I need to check whether it is possible to reach 80% of the population from the other potential agro-dealer locations.


### Remaining Population

```{r walking_remaining_population, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Walking Accessibility - Remaining Population", dev = 'png', results='markup'}

if ( run_heuristic_w == TRUE) {
 

  r_covered_pop_w <- r_cnfa_pop_w
  
  # remove the already covered population from the population grid to give remaining value
  r_remaining_pop_w <- pop_mwi_utm_rsmp - r_cnfa_pop_w
  
  # reclassify to show the area already covered as NA 
  r_remaining_pop_w_rcl  <-
    reclassify(r_remaining_pop_w, matrix(c(0, NA),
                                         ncol = 2,
                                         byrow = TRUE))
  
  r_remaining_pop_w_df <- gplot_data(r_remaining_pop_w_rcl)  # convert to geom_tile type of raster

remaining_pop_w_plot <- gplot(r_remaining_pop_w, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
    geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_sf(
    data = cnfa_ag_dealers_sdf,
    colour = 'dark green',
    size = 0.5,
    shape = 3,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = pot_ag_dealers_sdf,
    colour = 'blue',
    size = 0.5,
    shape = 1,
    inherit.aes = FALSE
  ) +
  scale_fill_gradient(
    low = 'yellow',
    high = 'red',
    na.value = NA,
    limits = c(0.5, 5000)
  ) +
  
  xlim(450000, 725000) +
  ylim(8300000, 8650000) +
  labs(fill = "-------------\nRemaining\nPopulation\nWalking\n-------------") +
  
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

print(remaining_pop_w_plot)

diff_pop_w <- cellStats(r_remaining_pop_w,stat='sum')
cat("Target Population = ", formatC(target_pop, format="d", big.mark=","),"\n\n")
cat("Total Population within 1 Hour = ", formatC(cnfa_pop_w, format="d", big.mark=","),"\n\n")
cat("Total Uncovered Population = ", formatC(diff_pop_w, format="d", big.mark=","),"\n\n")
cat("Remaining Population to Target = ", formatC((target_pop - cnfa_pop_w), format="d", big.mark=","),"\n\n")

potential_pop_w <- 0

}

```

```{r pop_rem_w_2_postgres, cache=TRUE, results='hide'}

if ( run_heuristic_w == TRUE) {
  
# this writes the  remaining pop surface to postgres

temp_points <- st_as_sf(rasterToPoints(r_remaining_pop_w, function(x){x>0}, spatial=TRUE))
temp_points$Id <- seq.int(nrow(temp_points))

st_write(obj = temp_points, dsn = con, Id(schema="coverage", table = "remaining_pop_w_points"))

}
```

### Total Time

```{r walking_access_potential, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Walking Accessibility - Potential Agro-Dealers", dev = 'png', results='hide'}

if ( run_heuristic_w == TRUE) {
  
pot_ag_dealers_sp <- as_Spatial(pot_ag_dealers_sdf)

pot_cost_w <- accCost(tr_w, pot_ag_dealers_sp)

access_pot_w_plot <- gplot(pot_cost_w, maxpixels = 50000) +
  geom_tile(aes(fill = value), alpha = 1) +
      geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
  geom_sf(
    data = pot_ag_dealers_sdf,
    ,
    colour = 'blue',
    size = 0.5,
    shape = 1,
    inherit.aes = FALSE
  ) +
  scale_fill_gradient(low = 'yellow',
                        high = 'red', 
                        na.value = NA, limits = c(0,10000)) +
  
  xlim(450000, 725000) +
  ylim(8300000, 8650000) +
  labs(fill = "-------------\nTime to\nnon-NGO\nPotential\nAgro-\nDealers\nWalking\n-------------") +
  
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  )

print(access_pot_w_plot)

}

```

### Within 1 hour

```{r walking_access_potential_1hr, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Within 1 hour - Walking Accessibility - Potential Agro-Dealers", dev = 'png', results='markup'}

if (run_heuristic_w == TRUE) {
  r_pot_1hr_w <-
    reclassify(pot_cost_w, matrix(c(-Inf, 3600, 1, 3600, Inf, 0),
                                  ncol = 3,
                                  byrow = TRUE))
  
  access_1hr_pot_w_plot <-   gplot(r_pot_1hr_w, maxpixels = 50000) +
    geom_tile(aes(fill = value), alpha = 1) +
        geom_sf(
    data = central_mask,
    fill = NA,
    col = 'dark grey',
    na.rm = TRUE,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_utm,
    fill = NA,
    colour = 'grey',
    size = 2,
    inherit.aes = FALSE
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1,
    inherit.aes = FALSE
  )    +
    geom_sf(
      data = pot_ag_dealers_sdf,
      colour = 'blue',
      size = 0.5,
      shape = 1,
      inherit.aes = FALSE
    ) +
    scale_fill_gradient(
      low = 'yellow',
      high = 'red',
      na.value = NA,
      limits = c(1, 1)
    ) +
    
    xlim(450000, 725000) +
    ylim(8300000, 8650000) +
    labs(fill = "-------------\nWithin\n1 hour of\nnon-NGO\nPotential\nAgro-\nDealers by\nWalking\n-------------") +
    
    theme(
      panel.grid.major.x = element_blank(),
      panel.grid.minor.x = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank()
    )
  
  print(access_1hr_pot_w_plot)
  r_pot_pop_w <- r_pot_1hr_w * r_remaining_pop_w
  pot_pop_w <- cellStats(r_pot_pop_w, stat = 'sum')
  cat(
    "Total Population within 1 hour of New Agro-Dealers by Walking (excluding population already covered by Existing Agro-Dealers) = ",
    pot_pop_w, "\n\n"
  )
  cnfa_pot_pop_w <- (cnfa_pop_w +  pot_pop_w)
  cat(
    "Total Population within 1 hour of both Existing and New Agro-Dealers by Walking = ",
    cnfa_pot_pop_w, "\n\n"
  )
    cat(
    "Target Population within 1 hour of both Existing and New Agro-Dealers by Walking = ",
    target_pop, "\n\n"
  )
  
  if (cnfa_pot_pop_w < target_pop) {
    run_heuristic_w <- FALSE
    cat(
      "Target Population still not reached. Do not run the heuristic for potential agro-dealers"
    )
    
  } else {
    run_heuristic_w <- TRUE
    cat("Target Population can be reached. Run the heuristic for potential agro-dealers")
  }
}

```

### Heuristic

```{r walking_g_add_potential, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Walking Accessibility - Potential Agro-Dealers", dev = 'png', results='markup'}


if (run_heuristic_w == TRUE) {
  # ----CREATE A TEMP DATAFRAME OF POINTS WITH ID GEOMETRY AND (EMPTY) pop1hr FIELD----
  
  temp_pot <- dplyr::select(pot_ag_dealers_sdf, id)
  temp_pot$pop1hr_w <- 0
  temp_pot_sp_w <-
    as_Spatial(temp_pot) # convert to sp for AccCost function
  
  # -----create a vector to store id of maxpop points-----
  
  highpop_pt_w <- c()
  
  # ----create an empty data frame of optimum points with attributes
  
  highpop_df_w <-
    data.frame(
      'id' = integer(),
      'pop_cap_j' = integer(),
      'iteration' = integer(),
      'pop_cap_tot' = integer()
    )
  
  
  # ----start loops----
  
  j = 0 # counter for number of iterations
  
  # ----PLOT START MAP AND CHARTS ----
  # ----plot the start map----
  
  access_g_add_1hr_pot_w_plot <- ggplot() +
    geom_sf(
      data = boundary_mcr_utm,
      fill = 'grey',
      col = NA,
      na.rm = TRUE,
      inherit.aes = FALSE
    ) +
    geom_tile(data = pop_mwi_utm_rsmp_df,
              aes(x = x, y = y, fill = value)) +
    geom_tile(
      data = dplyr::filter(r_remaining_pop_w_df, !is.na(value)),
      aes(x = x, y = y),
      fill = "grey20",
      alpha = 0.5
    )   +
    geom_tile(
      data = dplyr::filter(lc_c_mwi_rcl_water_df, !is.na(value)),
      aes(x = x, y = y),
      fill = "blue",
      alpha = 0.5
    )   +
    geom_sf(
      data = central_mask,
      fill = NA,
      col = 'dark grey',
      na.rm = TRUE,
      inherit.aes = FALSE
    ) +
    geom_sf(
      data = boundary_mcr_utm,
      fill = NA,
      colour = 'grey20',
      size = 1.5,
      inherit.aes = FALSE
    ) +
    geom_sf(
      data = boundary_mcr_dist_utm,
      fill = NA,
      colour = 'grey20',
      size = 0.75,
      inherit.aes = FALSE
    )    +
    geom_sf(
      data = cnfa_ag_dealers_sdf,
      colour = 'dark green',
      size = 1,
      aes(shape = "Existing"),
      inherit.aes = FALSE
    ) +
    geom_text(
      x = 660000,
      y = 8320000 ,
      aes(
        label = paste0(
          "Population within 1 Hour: ",
          formatC((cnfa_pop_w),
                  format = "d",
                  big.mark = ",")
        ),
        hjust = 'right'
      ),
      size = 4,
      colour = 'dark green'
    ) +
    geom_text(
      x = 660000,
      y = 8340000 ,
      aes(
        label = paste0("Target Population: ", formatC((target_pop),
                                                      format = "d",
                                                      big.mark = ","
        )),
        hjust = 'right'
      ),
      size = 4,
      colour = 'blue'
    ) +
    geom_text(
      x = 660000,
      y = 8360000 ,
      aes(label = paste0(j,  " New Agro-Dealers"),
          hjust = 'right'),
      size = 4,
      colour = 'black'
    ) +
    scale_shape_manual(name = "Agro-Dealers", values = c("Existing" = 3, "New" =
                                                           1)) +
    #scale_colour_manual(name = "", values = c("Existing" = "dark green", "New" = "blue")) +
    scale_fill_gradient(
      labels = comma,
      low = 'yellow',
      high = 'red',
      na.value = NA,
      limits = c(0.5, 10000)
    ) +
    scale_x_continuous(expand = c(0, 0),
                       limits = c(455000, 720000)) +
    scale_y_continuous(expand = c(0, 0),
                       limits = c(8305000, 8655000)) +
    labs(fill = expression(
      paste(
        "-------------\nPopulation\nWithin\n1 Hour\n-------------\npersons/km" ^
          2
      )
    )) +
    theme(
      #panel.background = element_rect(fill = 'white'),
      #panel.grid.major.x = element_blank(),
      #panel.grid.major.x = element_line(colour = 'grey'),
      #panel.grid.minor.x = element_blank(),
      panel.grid.minor.x = element_line(colour = 'grey'),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      panel.background = element_rect(fill = 'white', color = NA),
      panel.grid.major = element_line(color = 'grey', linetype = 'dotted'),
      panel.grid.minor = element_line(color = 'green', size = 2),
      legend.key = element_rect(fill = 'white')
    ) +
    guides(fill = guide_colourbar(order = 1),
           shape = guide_legend(order = 2))
  
  ## ----add a dummy point for plotting bar graph----
  crs <- st_crs(32736)
  dummy_point <- st_sf(
    id = NA,
    pop1hr_w = 0,
    pop_cap_j = 0,
    iteration = 0,
    pop_cap_tot = cnfa_pop_w,
    geometry = st_sfc(st_point(0:1)),
    crs = crs
  )
  
  ## ----plot the start bar chart----
  
  covered_population_plot <- ggplot(dummy_point) +
    geom_bar(aes(
      x = iteration,
      y = pop_cap_tot,
      alpha = (iteration / j)
    ),
    stat = 'identity',
    fill = 'dark green') +
    geom_point(aes(iteration, pop_cap_tot)) +
    geom_hline(
      yintercept = (target_pop),
      linetype = 'dashed',
      color = 'blue'
    ) +
    geom_text(
      x = 0,
      y =  target_pop - ((target_pop / 100) * 2.5),
      aes(label = "Target Population",
          hjust = 'left'),
      size = 4,
      colour = 'blue'
    ) +
    scale_alpha_continuous(guide = 'none') +
    scale_y_continuous(expand = c(0, 0),
                       labels = comma,
                       limits = c(0, max(
                         c(target_pop),
                         max(dummy_point$pop_cap_tot)
                       ))) +
    scale_x_continuous(
      expand = c(0, 0),
      labels = label_number(accuracy = 1),
      limits = c(0, (j + 1))#,
      #breaks = round(seq(0, j)),
      #1
    ) +
    labs(x = "New Agro-Dealers (#)", y = "Population within 1 Hour (#)") +
    theme(
      #panel.grid.major.x = element_blank(),
      #panel.grid.minor.x = element_blank(),
      #axis.title.x = element_blank(),
      axis.title.x = element_text(colour = 'grey20'),
      axis.title.y = element_text(colour = 'grey20'),
      axis.text.y = element_text(angle = 45),
      panel.background = element_rect(fill = 'white', color = NA),
      panel.grid.major.y = element_line(color = 'grey', linetype = 'dotted')
    )
  
  # ----combine map and bar chart ----
  
  
  access_covered <-
    plot_grid(
      access_g_add_1hr_pot_w_plot,
      covered_population_plot,
      align = "h",
      axis = "bt",
      rel_widths = c(1.3, 1)
    )
  
  
  # ----save combined plots as png ----
  ggsave(
    file = paste0("charts/access_g_add_1hr_pot_w_plot_", j, ".png"),
    plot = access_covered,
    width = 10,
    height = 5,
    units = "in",
    dpi = 300
  )
  
  # files uploaded to https://ezgif.com/ for animated gif
  
  # ----while target population not covered----
  
  while ((cnfa_pop_w + potential_pop_w) < target_pop) {
    j = j + 1
    
    
    # ----for every point in the temporary sp data frame----
    
    
    for (i in 1:length(temp_pot_sp_w)) {
      #print(j) # for debugging purposes
      
      # ----RUN COSTDISTANCE USING FRICTION GRID AND NEW TARGET POINT----
      acc_i_w <-
        accCost(tr_w, temp_pot_sp_w[i, ]) %>%
        reclassify(matrix(c(-Inf, 3600, 1, 3600, Inf, 0)))
      
      # ----multiply hour cost grid with remaining population get sum and add value to temporary sp data frame pop1hr_w field ----
      
      popsum_i_w <- (acc_i_w * r_remaining_pop_w)  %>%
        cellStats(stat = 'sum')
      
      temp_pot_sp_w[i, 2] <- popsum_i_w
      
    }
    
    # ----finish for loop----
    
    
    # ----COMPARE total_pop AND RECORD POINT-ID----
    
    # the index of the point with the maximum population covered
    highpop_index_w <- which.max(temp_pot_sp_w$pop1hr_w)
    print(paste(
      "Index of the point with the maximum population covered is : ",
      which.max(temp_pot_sp_w$pop1hr_w)
    ))
    
    # the id of the point with the maximum population covered using the index
    highpop_id_w <- temp_pot_sp_w$id[[highpop_index_w]]
    print(paste(
      "Id of the point with the maximum population covered is : ",
      highpop_id_w
    ))
    
    # the maximum population covered using the index
    print(paste(
      "Maximum population covered is : ",
      max(temp_pot_sp_w$pop1hr_w)
    ))
    
    # ----save the point with the maximum population covered in vector----
    
    highpop_pt_w <- append(highpop_pt_w, highpop_id_w)
    
    
    # ----RERUN THE COSTDISTANCE FOR THE OPTIMUM POINT , SAVE AND DISCARD----
    
    # using saved index
    
    acc_high_w <- accCost(tr_w, temp_pot_sp_w[highpop_index_w,]) %>%
      reclassify(matrix(c(-Inf, 3600, 1, 3600, Inf, 0)))
    
    # ----multiply hour cost grid with remaining population get sum ----
    
    popsum_high_w <- (acc_high_w * r_remaining_pop_w)
    potential_pop_i_w <- cellStats(popsum_high_w, stat = 'sum')
    cat(
      "Total Population within 1 hour of number",
      j ,
      " New Potential Agro-Dealer = ",
      potential_pop_i_w,
      "\n\n"
    )
    cat(
      "Total Population within 1 hour of all ",
      j ,
      " New Potential Agro-Dealers = ",
      (cnfa_pop_w + potential_pop_w + potential_pop_i_w),
      "\n\n"
    )
    
    # ----update population sums----
    
    # update covered population
    potential_pop_w <- potential_pop_i_w + potential_pop_w
    
    # update remaining population rasters
    r_remaining_pop_w <- r_remaining_pop_w - popsum_high_w
    
    # reclassify to show the area already covered as NA
    r_remaining_pop_w_rcl  <-
      reclassify(r_remaining_pop_w, matrix(c(0, NA),
                                           ncol = 2,
                                           byrow = TRUE))
    
    r_remaining_pop_w_df <-
      gplot_data(r_remaining_pop_w_rcl)  # convert to geom_tile type of raster
    
    
    # update remaining population
    diff_pop_w <- cellStats(r_remaining_pop_w, stat = 'sum')
    cat("Total Remaining Possible Population = ", diff_pop_w, "\n\n")
    cat(
      "Target Remaining Population = ",
      (target_pop - cnfa_pop_w - potential_pop_w),
      "\n\n"
    )
    
    # ----create a data frame of optimum points with attributes and inner-join to temporary points for mapping
    
    highpop_df_w <-
      rbind(
        highpop_df_w,
        data.frame(
          'id' = as.integer(highpop_id_w),
          'pop_cap_j' = as.integer(potential_pop_i_w),
          'iteration' = as.integer(j),
          'pop_cap_tot' = as.integer(cnfa_pop_w + potential_pop_w)
        )
      )
    
    new_pts_w <- inner_join(temp_pot, highpop_df_w, by = 'id')
    
    # ----remove latest optimum point from temp_pot_sp_w to reduce burden
    
    temp_pot_sp_w <- temp_pot_sp_w[-c(highpop_index_w), ]
    
    # ----PRODUCE MAP OF CAPTURED POPULATION AND BARCHART OF THIS ITERATION OF WHILE LOOP----
    
    # ----plot the map----
    
    access_g_add_1hr_pot_w_plot <- ggplot() +
      geom_sf(
        data = boundary_mcr_utm,
        fill = 'grey',
        col = NA,
        na.rm = TRUE,
        inherit.aes = FALSE
      ) +
      geom_tile(data = pop_mwi_utm_rsmp_df,
                aes(x = x, y = y, fill = value)) +
      geom_tile(
        data = dplyr::filter(r_remaining_pop_w_df,!is.na(value)),
        aes(x = x, y = y),
        fill = "grey20",
        alpha = 0.5
      )   +
      geom_tile(
        data = dplyr::filter(lc_c_mwi_rcl_water_df,!is.na(value)),
        aes(x = x, y = y),
        fill = "blue",
        alpha = 0.5
      )   +
      geom_sf(
        data = central_mask,
        fill = NA,
        col = 'dark grey',
        na.rm = TRUE,
        inherit.aes = FALSE
      ) +
      geom_sf(
        data = boundary_mcr_utm,
        fill = NA,
        colour = 'grey20',
        size = 1.5,
        inherit.aes = FALSE
      ) +
      geom_sf(
        data = boundary_mcr_dist_utm,
        fill = NA,
        colour = 'grey20',
        size = 0.75,
        inherit.aes = FALSE
      )    +
      geom_sf(
        data = cnfa_ag_dealers_sdf,
        colour = 'dark green',
        size = 1,
        aes(shape = "Existing"),
        inherit.aes = FALSE
      ) +
      geom_sf(
        data = new_pts_w,
        colour = 'dark green',
        size = 1,
        aes(shape = "New"),
        inherit.aes = FALSE
      ) +
      geom_text(
        x = 660000,
        y = 8320000 ,
        aes(
          label = paste0(
            "Population within 1 Hour: ",
            formatC((potential_pop_w + cnfa_pop_w),
                    format = "d",
                    big.mark = ","
            )
          ),
          hjust = 'right'
        ),
        size = 4,
        colour = 'dark green'
      ) +
      geom_text(
        x = 660000,
        y = 8340000 ,
        aes(
          label = paste0("Target Population: ", formatC((target_pop),
                                                        format = "d",
                                                        big.mark = ","
          )),
          hjust = 'right'
        ),
        size = 4,
        colour = 'blue'
      ) +
      geom_text(
        x = 660000,
        y = 8360000 ,
        aes(label = paste0(j, " New Agro-Dealers"),
            hjust = 'right'),
        size = 4,
        colour = 'black'
      ) +
      scale_shape_manual(name = "Agro-Dealers",
                         values = c("Existing" = 3, "New" = 1)) +
      scale_fill_gradient(
        labels = comma,
        low = 'yellow',
        high = 'red',
        na.value = NA,
        limits = c(0.5, 10000)
      ) +
      scale_x_continuous(expand = c(0, 0),
                         limits = c(455000, 720000)) +
      scale_y_continuous(expand = c(0, 0),
                         limits = c(8305000, 8655000)) +
      labs(fill = expression(
        paste(
          "-------------\nPopulation\nWithin\n1 Hour\n-------------\npersons/km" ^
            2
        )
      )) +
      theme(
        #panel.background = element_rect(fill = 'white'),
        #panel.grid.major.x = element_blank(),
        #panel.grid.major.x = element_line(colour = 'grey'),
        #panel.grid.minor.x = element_blank(),
        panel.grid.minor.x = element_line(colour = 'grey'),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.background = element_rect(fill = 'white', color = NA),
        panel.grid.major = element_line(color = 'grey', linetype = 'dotted'),
        panel.grid.minor = element_line(color = 'green', size = 2),
        legend.key = element_rect(fill = 'white')
      ) +
      guides(fill = guide_colourbar(order = 1),
             shape = guide_legend(order = 2))
    
    ## ----add a dummy point for plotting bar graph----
    crs <- st_crs(32736)
    dummy_point <- st_sf(
      id = NA,
      pop1hr_w = 0,
      pop_cap_j = 0,
      iteration = 0,
      pop_cap_tot = cnfa_pop_w,
      geometry = st_sfc(st_point(0:1)),
      crs = crs
    )
    
    new_pts_w_dummy <- rbind(new_pts_w, dummy_point)
    
    ## ----plot the bar chart----
    
    covered_population_plot <- ggplot(new_pts_w_dummy) +
      geom_bar(aes(
        x = iteration,
        y = pop_cap_tot,
        alpha = (iteration / j)
      ),
      stat = 'identity',
      fill = 'dark green',) +
      geom_point(aes(iteration, pop_cap_tot)) +
      geom_hline(
        yintercept = (target_pop),
        linetype = 'dashed',
        color = 'blue'
      ) +
      geom_text(
        x = 0,
        y =  target_pop - ((target_pop / 100) * 2.5),
        aes(label = "Target Population",
            hjust = 'left'),
        size = 4,
        colour = 'blue'
      ) +
      scale_alpha_continuous(guide = 'none') +
      scale_y_continuous(
        expand = c(0, 0),
        labels = comma,
        limits = c(0, max(
          c(target_pop),
          max(new_pts_w_dummy$pop_cap_tot)
        ))
      ) +
      scale_x_continuous(
        expand = c(0, 0),
        labels = label_number(accuracy = 1),
        limits = c(0, (j + 1))#,
        #breaks = round(seq(0, j)),
        #1
      ) +
      labs(x = "New Agro-Dealers (#)", y = "Population within 1 Hour (#)") +
      theme(
        #panel.grid.major.x = element_blank(),
        #panel.grid.minor.x = element_blank(),
        #axis.title.x = element_blank(),
        axis.title.x = element_text(colour = 'grey20'),
        axis.title.y = element_text(colour = 'grey20'),
        axis.text.y = element_text(angle = 45),
        panel.background = element_rect(fill = 'white', color = NA),
        panel.grid.major.y = element_line(color = 'grey', linetype = 'dotted')
      )
    
    # ----combine map and bar chart ----
    
    
    access_covered <-
      plot_grid(
        access_g_add_1hr_pot_w_plot,
        covered_population_plot,
        align = "h",
        axis = "bt",
        rel_widths = c(1.3, 1)
      )
    
    
    # ----save combined plots as png ----
    ggsave(
      file = paste0("charts/access_g_add_1hr_pot_w_plot_", j, ".png"),
      plot = access_covered,
      width = 10,
      height = 5,
      units = "in",
      dpi = 300
    )
    
    # files uploaded to https://ezgif.com/ for animated gif
    
  }
  
  cat("Completed after ", j, "iterations\n\n")
  
  # ----CLEAN UP----
  # re-initialise values
  
  potential_pop_w <- 0
  r_remaining_pop_w <- pop_mwi_utm_rsmp - r_cnfa_pop_w
  
}


```

# Purely PostGIS vector solution

## Convert raster to centroids and polygons

The rasters for the population and the friction surfaces were converted to centroids and written to postgresql

The maps show a zoom of the area around Lilongwe:

```{r postgresql_pop_points, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Population raster converted to centroids", dev = 'png', results='hide'}

# query to select easting, northing, yield from pg for job
qry <- sprintf("SELECT  *  FROM COVERAGE.POP_MWI_POINTS")

# fetch data from db,
pop_mwi_utm_rsmp_postgres <- dbGetQuery(con, qry)


# https://stackoverflow.com/questions/58398074/import-csv-with-postgres-geometry-column-as-sf

#1. convert the geometry strings to sf spatial objects:
newGeom <-
  st_as_sfc(structure(as.character(pop_mwi_utm_rsmp_postgres$geometry), class = "WKB"), EWKB =
              TRUE)

#2. create a new spatial data frame with the new spatial objects as geometry
pop_mwi_utm_rsmp_postgres_sdf <-
  st_set_geometry(pop_mwi_utm_rsmp_postgres, newGeom)

#3. (optional) drop the character format column
pop_mwi_utm_rsmp_postgres_sdf$geom = NULL

st_crs(pop_mwi_utm_rsmp_postgres_sdf, 32736)

pop_mwi_postgres_plot <- ggplot() +
  
  geom_sf(data = boundary_mcr_utm,
          colour = 'grey',
          size = 2) +
  geom_sf(data = pop_mwi_utm_rsmp_postgres_sdf,
          aes(colour = layer),
          size = 1,
          shape = 20) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1
  ) +
  scale_colour_gradient(
    labels = comma,
    low = 'yellow',
    high = 'red',
    na.value = NA,
    limits = c(0.5, 15000)
  ) +
  scale_x_continuous(expand = c(0, 0),
                     limits = c(575000, 585000)) +
  scale_y_continuous(expand = c(0, 0),
                     limits = c(8440000, 8455000)) +
  labs(colour = "-------------\nPostGIS\nPopulation\nper 1km\npoint\nZoomed\n-------------")

pop_mwi_postgres_plot

```

```{r postgresql_friction_points, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Bicycle friction raster converted to centroids", dev = 'png', results='hide'}

# query to select centroids
qry <- sprintf("SELECT  *  FROM COVERAGE.FRICTION_B_POINTS")

# fetch data from db,
friction_b_postgres <- dbGetQuery(con, qry)


# https://stackoverflow.com/questions/58398074/import-csv-with-postgres-geometry-column-as-sf

#1. convert the geometry strings to sf spatial objects:
newGeom <-
  st_as_sfc(structure(as.character(friction_b_postgres$geometry), class = "WKB"), EWKB =
              TRUE)

#2. create a new spatial data frame with the new spatial objects as geometry
friction_b_postgres_sdf <-
  st_set_geometry(friction_b_postgres, newGeom)

#3. (optional) drop the character format column
friction_b_postgres_sdf$geom = NULL

st_crs(friction_b_postgres_sdf, 32736)

# query to select raster edges
qry <- sprintf("SELECT  *  FROM COVERAGE.FRICTION_B_RASTER_EDGES")

# fetch data from db,
friction_b_edges_postgres <- dbGetQuery(con, qry)


# https://stackoverflow.com/questions/58398074/import-csv-with-postgres-geometry-column-as-sf

#1. convert the geometry strings to sf spatial objects:
newGeom <-
  st_as_sfc(structure(as.character(friction_b_edges_postgres$geometry), class = "WKB"), EWKB =
              TRUE)

#2. create a new spatial data frame with the new spatial objects as geometry
friction_b_edges_postgres_sdf <-
  st_set_geometry(friction_b_edges_postgres, newGeom)

#3. (optional) drop the character format column
friction_b_edges_postgres_sdf$geom = NULL

st_crs(friction_b_edges_postgres_sdf, 32736)

# query to select raster vertices
qry <- sprintf("SELECT  *  FROM COVERAGE.FRICTION_B_RASTER_VERTICES")

# fetch data from db,
friction_b_vertices_postgres <- dbGetQuery(con, qry)


# https://stackoverflow.com/questions/58398074/import-csv-with-postgres-geometry-column-as-sf

#1. convert the geometry strings to sf spatial objects:
newGeom <-
  st_as_sfc(structure(as.character(friction_b_vertices_postgres$geometry), class = "WKB"), EWKB =
              TRUE)

#2. create a new spatial data frame with the new spatial objects as geometry
friction_b_vertices_postgres_sdf <-
  st_set_geometry(friction_b_vertices_postgres, newGeom)

#3. (optional) drop the character format column
friction_b_vertices_postgres_sdf$geom = NULL

st_crs(friction_b_vertices_postgres_sdf, 32736)


friction_b_postgres_plot <- ggplot() +
  
  geom_sf(data = boundary_mcr_utm,
          colour = 'grey',
          size = 2) +
  geom_sf(data = friction_b_edges_postgres_sdf,
          colour = "grey",
          size = 0.5) +
  geom_sf(data = friction_b_vertices_postgres_sdf,
          colour = "grey",
          size = 1,
          shape = 1) +
  geom_sf(data = friction_b_postgres_sdf,
          aes(colour = layer),
          size = 3,
          shape = 20) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1
  ) +
  scale_colour_gradientn(colours = cols,
                         na.value = NA,
                         limits = c(0, 3600)) +
  scale_x_continuous(expand = c(0, 0),
                     limits = c(575000, 585000)) +
  scale_y_continuous(expand = c(0, 0),
                     limits = c(8440000, 8455000)) +
  labs(colour = "-------------\nPostGIS\nFriction\nSurface\nBicycles\npoint\nZoomed\n-------------")

friction_b_postgres_plot

```

## Create lines between all centroids 

First the lines between the nearest four raster centroids (white) in the cardinal directions were defined, and then the lines between the nearest four raster vertices in the ordinal directions (grey).

The cost of travelling between centroid x1 and centroid x2 along the cardinal line was (cost x1 + cost x2) / 2 

The cost of travelling between vertex y1 and centroid x1 along the ordinal line was cost x1  * (distance y1-x1 / 1000)

The cardinal and ordinal lines were then combined.

```{r postgresql_lines, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Bicycle friction network", dev = 'png', results='hide'}

# query to select centroids
qry <- sprintf("SELECT  *  FROM COVERAGE.FRICTION_B_LINES_CARDINAL_NO_DUPES")

# fetch data from db,
friction_b_lines_c_postgres <- dbGetQuery(con, qry)


# https://stackoverflow.com/questions/58398074/import-csv-with-postgres-geometry-column-as-sf

#1. convert the geometry strings to sf spatial objects:
newGeom <-
  st_as_sfc(structure(as.character(friction_b_lines_c_postgres$geom), class = "WKB"), EWKB =
              TRUE)

#2. create a new spatial data frame with the new spatial objects as geometry
friction_b_lines_c_postgres_sdf <-
  st_set_geometry(friction_b_lines_c_postgres, newGeom)

#3. (optional) drop the character format column
friction_b_lines_c_postgres_sdf$geom = NULL

st_crs(friction_b_lines_c_postgres_sdf, 32736)

# query to select raster edges
qry <- sprintf("SELECT  *  FROM COVERAGE.FRICTION_B_LINES_ORDINAL_NO_DUPES")

# fetch data from db,
friction_b_lines_o_postgres <- dbGetQuery(con, qry)


# https://stackoverflow.com/questions/58398074/import-csv-with-postgres-geometry-column-as-sf

#1. convert the geometry strings to sf spatial objects:
newGeom <-
  st_as_sfc(structure(as.character(friction_b_lines_o_postgres$geom), class = "WKB"), EWKB =
              TRUE)

#2. create a new spatial data frame with the new spatial objects as geometry
friction_b_lines_o_postgres_sdf <-
  st_set_geometry(friction_b_lines_o_postgres, newGeom)

#3. (optional) drop the character format column
friction_b_lines_o_postgres_sdf$geom = NULL

st_crs(friction_b_lines_o_postgres_sdf, 32736)


friction_b_lines_postgres_plot <- ggplot() +
  
  geom_sf(data = boundary_mcr_utm,
          colour = 'grey',
          size = 2) +
  geom_sf(data = friction_b_lines_o_postgres_sdf,
          colour = "grey",
          size = 0.5) +
  geom_sf(data = friction_b_lines_c_postgres_sdf,
          colour = "white",
          size = 0.5) +
  geom_sf(data = friction_b_vertices_postgres_sdf,
          colour = "grey",
          size = 1,
          shape = 1) +
  geom_sf(data = friction_b_postgres_sdf,
          aes(colour = layer),
          size = 3,
          shape = 20) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1
  ) +
  scale_colour_gradientn(colours = cols,
                         na.value = NA,
                         limits = c(0, 3600)) +
  scale_x_continuous(expand = c(0, 0),
                     limits = c(575000, 585000)) +
  scale_y_continuous(expand = c(0, 0),
                     limits = c(8440000, 8455000)) +
  labs(colour = "-------------\nPostGIS\nFriction\nSurface\nBicycles\nlines\nZoomed\n-------------")

gc()
friction_b_lines_postgres_plot

```

## Create a network suitable for pgrdijkstra routing algorithm

The prgdijkstra function in the pgrouting extension requires input data with a specific topological structure of nodes and edges.

The nodes are created using the following SQL query:

*select pgr_nodenetwork('COVERAGE.FRICTION_B_LINES_COMBINED_NO_DUPES', 0.000001, 'comb_id', 'geom', 'noded')*
 
This produces the *COVERAGE.FRICTION_B_LINES_COMBINED_NO_DUPES_NODED* table of edges with the following columns:

* id
* old_id
* sub_id
* source (with null values)
* target (with null values)
* geom

The graph network is then created using this SQL query:

*select pgr_createTopology('COVERAGE.FRICTION_B_LINES_COMBINED_NO_DUPES_NODED', 0.000001, 'geom', 'id', 'source', 'target' )*

This produces the *COVERAGE.FRICTION_B_LINES_COMBINED_NO_DUPES_NODED_VERTICES_PGR* table of nodes with the following columns:

* id
* cnt
* chk
* ein
* eout
* the_geom

The edge_table will be affected with changes to the source and target column values. 

To complete the network the cost and reverse cost columns and values need to be added to the edges table.
These costs are the same, and are equivalent to the cost column of combined ordinal and cardinal lines table that I created earlier.

The network can be analysed using the following query:

*select pgr_analyzegraph('COVERAGE.FRICTION_B_LINES_COMBINED_NO_DUPES_NODED', 0.000001,'geom','id','source','target','true')*

This returns an *OK* statement and fills completely the cnt and chk columns of the nodes table.

## Snap agro-dealers to nearest node

The network is now ready for running the pgrdijkstra function but the nodes table needs extra columns with information on the agro-dealers and the population at each node. The population can be added easily because the population points are already located at the node locations. The potential new agro-dealers, however, are not located at the node locations so need to be snapped to the nearest node.

The snapping uses the PostGIS indexes *<->* distance ordering, and the *CROSS JOIN LATERAL* via a new table.

```{r postgresql_snapped_pot_ag_dealers, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "agro-dealers snapped to bicycle friction network", dev = 'png', results='hide'}

# query to select snapped agro-dealers
qry <- sprintf("SELECT  *  FROM COVERAGE.POT_AG_DEALERS_SNAP")

# fetch data from db,
snapped_pot_ag_dealers_postgres <- dbGetQuery(con, qry)


# https://stackoverflow.com/questions/58398074/import-csv-with-postgres-geometry-column-as-sf

#1. convert the geometry strings to sf spatial objects:
newGeom <-
  st_as_sfc(structure(as.character(snapped_pot_ag_dealers_postgres$moved_geom), class = "WKB"), EWKB =
              TRUE)

#2. create a new spatial data frame with the new spatial objects as geometry
snapped_pot_ag_dealers_postgres_sdf <-
  st_set_geometry(snapped_pot_ag_dealers_postgres, newGeom)

#3. (optional) drop the character format column
snapped_pot_ag_dealers_postgres_sdf$geom = NULL

st_crs(snapped_pot_ag_dealers_postgres_sdf, 32736)


snapped_pot_ag_dealers_postgres_plot <- ggplot() +
  
  geom_sf(data = boundary_mcr_utm,
          colour = 'grey',
          size = 2) +
  geom_sf(data = friction_b_lines_o_postgres_sdf,
          colour = "grey",
          size = 0.5) +
  geom_sf(data = friction_b_lines_c_postgres_sdf,
          colour = "white",
          size = 0.5) +
  geom_sf(
    data = friction_b_vertices_postgres_sdf,
    colour = "grey",
    size = 1,
    shape = 1
  ) +
  geom_sf(data = friction_b_postgres_sdf,
          aes(colour = layer),
          size = 3,
          shape = 20) +
  geom_sf(
    data = pot_ag_dealers_sdf,
    size = 3,
    aes(fill = "New"),
    shape = 21,
    alpha = 0.5
  ) +
  geom_sf(
    data = snapped_pot_ag_dealers_postgres_sdf,
    size = 3,
    aes(fill = "Snapped"),
    shape = 21,
    alpha = 0.5
  ) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1
  ) +
  scale_fill_manual(name = "Agro-Dealers",
                    values = c("New" = "red",
                               "Snapped" = "blue")) +
  scale_colour_gradientn(colours = cols,
                         na.value = NA,
                         limits = c(0, 3600)) +
  scale_x_continuous(expand = c(0, 0),
                     limits = c(585000, 590000)) +
  scale_y_continuous(expand = c(0, 0),
                     limits = c(8447500, 8455000)) +
  labs(fill = "-------------\nPostGIS\nFriction\nSurface\nBicycles\nAgro-\n Dealers\nZoomed\n-------------") +
  labs(colour = "-------------\nPostGIS\nFriction\nSurface\nBicycles\nlines\nZoomed\n-------------") +
  theme(
    #panel.background = element_rect(fill = 'white'),
    #panel.grid.major.x = element_blank(),
    #panel.grid.major.x = element_line(colour = 'grey'),
    #panel.grid.minor.x = element_blank(),
    panel.grid.minor.x = element_line(colour = 'grey'),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.background = element_rect(fill = 'white', color = NA),
    panel.grid.major = element_line(color = 'grey', linetype = 'dotted'),
    panel.grid.minor = element_line(color = 'green', size = 2),
    legend.key = element_rect(fill = 'white')
  )
gc()
snapped_pot_ag_dealers_postgres_plot

```



```{r postgresql_full_network, cache=TRUE, fig.height = 5, fig.width = 4, fig.cap = "Agro-dealers and population joined to the network", dev = 'png', results='hide'}

# query to select network nodes
qry <- sprintf("SELECT  *  FROM COVERAGE.FRICTION_B_LINES_COMBINED_NO_DUPES_NODED_VERTICES_PGR")

# fetch data from db,
network_nodes_postgres <- dbGetQuery(con, qry)


# https://stackoverflow.com/questions/58398074/import-csv-with-postgres-geometry-column-as-sf

#1. convert the geometry strings to sf spatial objects:
newGeom <-
  st_as_sfc(structure(as.character(network_nodes_postgres$the_geom), class = "WKB"), EWKB =
              TRUE)

#2. create a new spatial data frame with the new spatial objects as geometry
network_nodes_postgres_sdf <-
  st_set_geometry(network_nodes_postgres, newGeom)

#3. (optional) drop the character format column
network_nodes_postgres_sdf$geom = NULL

st_crs(network_nodes_postgres_sdf, 32736)

# query to select network edges
qry <- sprintf("SELECT  *  FROM COVERAGE.FRICTION_B_LINES_COMBINED_NO_DUPES_NODED")

# fetch data from db,
network_edges_postgres <- dbGetQuery(con, qry)


# https://stackoverflow.com/questions/58398074/import-csv-with-postgres-geometry-column-as-sf

#1. convert the geometry strings to sf spatial objects:
newGeom <-
  st_as_sfc(structure(as.character(network_edges_postgres$geom), class = "WKB"), EWKB =
              TRUE)

#2. create a new spatial data frame with the new spatial objects as geometry
network_edges_postgres_sdf <-
  st_set_geometry(network_edges_postgres, newGeom)

#3. (optional) drop the character format column
network_edges_postgres_sdf$geom = NULL

st_crs(network_edges_postgres_sdf, 32736)

network_postgres_plot <- ggplot() +
  
  geom_sf(data = boundary_mcr_utm,
          colour = 'grey',
          size = 2) +
  geom_sf(data = network_edges_postgres_sdf,
          aes(colour = cost),
          size = 1) +
  geom_sf(data = network_nodes_postgres_sdf,
          aes(size = pop_b),
          colour = 'red',
          fill = 'white',
          shape = 22,
          alpha = 0.75) +
  geom_sf(data = network_nodes_postgres_sdf,
          aes(shape = ag_new_id),
          colour = 'blue',
          fill = 'white',
          alpha = 0.75) +
  geom_sf(
    data = boundary_mcr_dist_utm,
    fill = NA,
    colour = 'black',
    size = 1
  ) +
  scale_size_area() +
  scale_shape_binned(breaks = c(0,Inf)) +
  scale_colour_gradientn(colours = cols,
                         na.value = NA,
                         limits = c(0, 3600)) +
  scale_x_continuous(expand = c(0, 0),
                     limits = c(585000, 590000)) +
  scale_y_continuous(expand = c(0, 0),
                     limits = c(8447500, 8455000)) +
  labs(size = "-------------\nPopulation\nZoomed\n-------------") +
  labs(shape = "Agro-\nDealers") +
  labs(colour = "-------------\nFriction\nSurface\nBicycles\n-------------") +
  theme(
    #panel.background = element_rect(fill = 'white'),
    #panel.grid.major.x = element_blank(),
    #panel.grid.major.x = element_line(colour = 'grey'),
    #panel.grid.minor.x = element_blank(),
    panel.grid.minor.x = element_line(colour = 'grey'),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.background = element_rect(fill = 'white', color = NA),
    panel.grid.major = element_line(color = 'grey', linetype = 'dotted'),
    panel.grid.minor = element_line(color = 'green', size = 2),
    legend.key = element_rect(fill = 'white')
  )
gc()
network_postgres_plot

```

## Run greedy-add heuristic using pgrdijkstra routing algorithm

The pgrouting method in PostgreSQL is more complicated than the gdistance method in R because the path has to be calculated from each populated node to each agro-dealer node individually.

A number of methods were tried. A method that used pgrdijkstra with combination queries (many-to-many) caused memory problems. A different method that used a one-to-many query with temporary tables to store information suffered from problems with transaction locks. Eventually a method of many-to-one path analysis with results and inputs in arrays was successful.

The pgrouting method is similar to the gdistance heuristic and has the following steps:

1.  Declare variables used internally in the functiion
2.  Add variables to the *COVERAGE.FRICTION_B_LINES_COMBINED_NO_DUPES_NODED_VERTICES_PGR* table for recording the population remaining, the status of the agro-dealer (chosen or not), and the iteration
3. Start a WHILE loop based on the population target to be reached during the heuristic
4. Open a cursor with a record for each potential agro-dealer
5. Start a loop through all cursor records
6. Get all population source locations within 15km of the target agro-dealer (this is the maximum distance that a source can be from the target given the 15km/hr maximum bicycle speed on roads with no slope) and save in an array
7. Construct a query in text using a special format function for the arrays to run the pgrdijkstra functiion
8. Execute the query text to run the pgrdijkstra using the source array (many) and the agro-dealer target array (one) 
9. Record the population of each source that is within 1 hour of the target in an array
10. Calculate the sum of the source population for each target agro-dealer and record the maximum population and the target agro-dealer
11. Finish the loop
12. Repeat the above loop for just the target agro-dealer (also get the id of each source population point within 1 hour) and update the new columns in the *COVERAGE.FRICTION_B_LINES_COMBINED_NO_DUPES_NODED_VERTICES_PGR* table
13. Repeat the above as the WHILE loop until the population target is reached and the close loop



